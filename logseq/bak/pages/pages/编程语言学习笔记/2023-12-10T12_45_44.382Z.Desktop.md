- **编程**
  collapsed:: true
	- **PYTHON**
	  collapsed:: true
		- # PYTHON第一章
		  collapsed:: true
			- ## python的起源
			  collapsed:: true
				- Python语言的起源可以追溯到上个世纪90年代初，在荷兰的Guido van Rossum开发了它。Guido当时想要创建一种简单易学、具有良好的可读性和可维护性，并且适合完成各种编程任务的语言，因此Python应运而生。这门语言最初被称为ABC语言的继承者，但很快就发展出了与ABC不同的独特特性和语法规则。随着社区的不断发展，Python逐渐成为一门流行的编程语言，在数据科学、机器学习、Web开发等领域应用广泛。
			- ## python 的优点
			  collapsed:: true
				- Python有许多优点，这里列举一些：
				  
				  1. 简单易读：Python采用简洁的语法和清晰的代码风格，易于阅读和上手，非常适合初学者和教育领域。
				  
				  2. 广泛应用：Python应用广泛，可以应用于Web开发、科学计算、数据分析、人工智能、自动化测试等各种领域。
				  
				  3. 大量的开源库和框架 ：Python有丰富的开源工具和库，例如NumPy、Pandas、Matplotlib、Scrapy等，可以快速构建高效、强大的应用程序。
				  
				  4. 可移植性强：Python可以在多个平台上运行，如Windows、Linux、macOS等，只需稍作修改就可以在不同的平台上运行。
				  
				  5. 支持面向对象编程：Python是一种面向对象编程语言，支持多种编程模式，如面向对象编程、函数式编程、命令式编程等。
				  
				  6. 大型社区和活跃的开发者：Python拥有一个大型的社区和活跃的开发者社区，提供了持续的技术支持和开发工具。
				  
				  7. 可扩展性好：Python可以很容易地与其他语言集成，也可以使用C/C++扩展Python的功能，实现高性能的计算任务。
			- ## 什么是编程语言？
			  collapsed:: true
				- 编程语言是一种计算机语言，用于与计算机交互并编写计算机程序。它是一种为了人们与计算机之间交流而设计的语言，它可以翻译成计算机可以理解的指令，执行各种任务。编程语言可以分为高级语言和低级语言，高级语言通常更易于理解和使用，低级语言更接近计算机硬件。常见的编程语言有C、Java、Python、JavaScript等。
		- # PYTHON第二章
		  collapsed:: true
			- ## 第一节 字面量
			  collapsed:: true
				- ### 什么是字面量？
				  collapsed:: true
					- 字面量是一种用于表示固定值的语法符号。在Python中，常见的字面量包括数字、字符串、布尔值、列表、元组、字典和集合等。字面量直接表示其对应的值，而不需要通过变量命名或其他操作进行赋值。例如，在Python中，字符串字面量可以用单引号或双引号括起来表示一个字符串值，如："Hello, world!"。同样，数字字面量可以直接用数字表示，如：1024。字面量在Python中非常常用，是编写Python代码的基础。
				- ### 常用值类型
				  collapsed:: true
					- 常用的值类型包括整数类型（例如int，long，short等），浮点数类型（例如float，double），布尔类型（例如bool)，字符类型（例如char)，枚举类型（例如enum)，以及空类型（例如void). 这些类型在编程中用于存储不同种类的数据，以便进行计算和操作。
					- 字符串
						- 字符串是一种数据类型，通常用来表示文本数据。它由一系列的字符组成，可以是字母、数字、标点符号、空格等等。在计算机程序中，字符串可以被操作、修改、转换和输出。常见的字符串操作有连接、替换、截取等。在编程语言中，字符串类型通常被赋予特定的表示方式和内置的操作函数，以方便程序员对其进行处理。
				- ### 如何基于print语句完成各类字面量的输入？
				  collapsed:: true
					- 您可以使用print语句在控制台中输出各种字面量。例如，您可以使用以下代码输出字符串字面量：
					  
					  ```
					  print('Hello, World!')
					  ```
					  
					  您还可以使用print语句输出数字字面量，例如：
					  
					  ```
					  print(42)
					  ```
					  
					  您甚至可以输出布尔值字面量，例如：
					  
					  ```
					  print(True)
					  print(False)
					  ``` 
					  
					  总之，在Python中，使用print语句输出各种字面量是非常简单的。
			- ## 第二节 注释
			  collapsed:: true
				- ### 注释的作用
				  collapsed:: true
					-
					- 注释是程序中用来描述和解释代码的一种方式。它能够帮助其他程序员理解代码，并且可以提高代码的可读性和可维护性。注释可以用于解释代码的目的、实现细节、算法原理、接口说明、代码片段的作用等等。此外，注释还可以用于标记代码的TODO项、提醒其他程序员注意事项、以及记录关键决策点等。注释包含在代码中，但是在编译时会被编译器忽略，因此对程序的运行不会有影响。
				- ### Python注释的分类
				  collapsed:: true
					- Python注释可以分为两种：
					  
					  1. 单行注释：以 # 开头，用于注释单行代码或解释代码。#   后面要加空格
					  
					  示例： 
					  
					  ``` python
					  # 这是一个单行注释
					  
					  a = 1  # 这是一个单行注释，用于解释变量a的作用
					  ```
					  
					  2. 多行注释：也叫文档注释，用于注释多行代码，通常用于模块、类、函数等的说明文档。
					  
					  示例：
					  
					  ``` python
					  """
					  这是一个多行注释
					  可以用于注释多个代码块
					  例如函数、模块的说明文档等。
					  """
					  
					  def add(a, b):
					      """
					      这是一个函数的多行注释，
					      用于解释函数的功能、参数、返回值等
					      """
					      return a + b
					  ```
			- ## 第三节 变量
			  collapsed:: true
				- ### python中变量是什么，有什么作用？
					- 在Python中，变量是用于存储数据的名称或标识符。通过将值分配给变量，我们可以在程序中使用它。变量可以存储各种数据类型，如数字，字符串，布尔值等。通过使用变量，我们可以轻松地引用或操作数据。变量可以在程序中用于多种用途，如存储输入值，计算结果，表示状态等。在Python中，变量是动态类型的，因此可以灵活地修改变量的值和类型。
				- ### python变量的定义格式
					- Python变量的定义格式是：变量名 = 值，其中变量名可以是任何合法的标识符，值可以是数字、字符串、布尔值、列表、元组、字典、函数等。在Python中，变量名不需要事先声明，赋值操作将会自动创建变量。例如：
					  
					  ```
					  message = "Hello, world!"
					  num = 42
					  is_true = True
					  my_list = [1, 2, 3]
					  ```
					  
					  在变量名和值之间使用等号（=）符号进行赋值操作。Python是一种动态类型语言，所以不需要在定义变量时显式指定类型。
				- ### python 变量的特征？
				  collapsed:: true
					- Python 变量的特征包括：
					  
					  1. 命名规则：变量名必须以下划线或字母开头，不能以数字开头，可以包含字母、数字和下划线。
					  
					  2. 类型推导：Python 是一种动态类型语言，变量的类型由赋值语句决定，无需显式声明数据类型。
					  
					  3. 引用机制：Python 的变量是对内存空间的引用，所以变量可以引用任何类型的对象，包括整型、浮点型、字符串类型、列表类型、字典类型等等。
					  
					  4. 动态赋值：在 Python 中，变量可以随时被重新赋值，新值可以与旧值具有不同的类型和长度。
					  
					  5. 删去机制：Python 中的变量可以被 del 关键字删除，从而释放其占用的内存空间。
				- ### 拓展
				- print语句如何输出多份内容
					- 您可以使用逗号分隔每个要输出的项，如下所示：
					  
					  ```
					  print("内容1", "内容2", "内容3")
					  ```
					  
					  这将输出三个部分，分别是“内容1”，“内容2”和“内容3”，它们都位于同一行上。您还可以在每个要输出的项之间插入字符串或其他字符，以便更好地区分它们。例如：
					  
					  ```
					  print("第一份内容：", "内容1", "\n第二份内容：", "内容2")
					  ```
					  
					  这将输出两个部分，第一个部分是“第一份内容：内容1”，第二个部分是“第二份内容：内容2”。注意我们在字符串中使用了“\n”，它表示新行。
				-
			- ## 第四节 数据类型
			  collapsed:: true
				- ### python使用什么语句可以查看数据类型
					- 在Python中，可以使用type()函数来查看数据类型。例如，如果有一个变量名为x，如果您想知道它的数据类型，则可以使用下面的语句：
					  
					  ```
					  type(x)
					  ```
					  
					  这将返回x的数据类型，例如int，float，str或list等。
				- ### python中变量有没有类型？
					- Python是一种动态类型语言，它的变量是没有固定类型的，也就是说变量的类型是可以随着其值改变的。例如，一个变量在一个时刻可以被赋值为整数类型，而在另一个时刻可以被赋值为字符串类型。因此，Python中的变量不需要在声明时指定类型，它会根据赋值的数据自动推导变量的类型。
				-
			- ## 第五节  数据类型转换
			  collapsed:: true
				- ### python为什么要转换数据类型
				  collapsed:: true
					- Python中的数据类型转换是将一种数据类型转换为另一种数据类型的过程。这是因为不同的数据类型在处理和使用上可能存在差异。例如，在进行算术运算时，数值型数据类型（如整数和浮点数）可以进行加、减、乘、除等运算，但在字符串类型中不能进行这些运算。因此，我们需要将输入的字符串类型转换为数值型类型才能进行运算。此外，在进行数据处理和分析时，有时候需要将数据转换为不同的类型，从而便于计算和处理数据。因此，数据类型转换对于Python编程非常重要。
				- ### python中常见的转换语句
				  collapsed:: true
					- 在Python中，常见的转换语句有以下几种：
					  
					  1. int()：将一个字符串或浮点数转换为整数。
					  2. float()：将一个字符串或整数转换为浮点数。
					  3. str()：将一个数值或其他类型的数据转换为字符串类型。
					  4. bool()：将一个数值或其他类型的数据转换为布尔值类型。
					  5. list()：将一个可迭代对象（如字符串、元组、列表等）转换为列表。
					  6. tuple()：将一个可迭代对象（如字符串、列表、元组等）转换为元组。
					  7. set()：将一个可迭代对象（如字符串、列表、元组等）转换为集合。
					  8. dict()：将一个包含键值对的元组列表或字典转换为字典类型。
				- ### 任何类型都可以转换成字符串吗？
				  collapsed:: true
					- 几乎所有类型都可以转换成字符串。在许多编程语言中，可以使用类型转换函数或方法将其他类型的数据转换为字符串。例如，在Python中，可以使用`str()`函数将数值、布尔值、列表、元组、字典等各种数据类型转换为字符串。但是，对于一些特殊类型，如函数和类，转换为字符串可能不是有意义的操作。
				- ### python中字符串可以随意转换成数字吗？
				  collapsed:: true
					- 在 Python 中，字符串可以通过一些内置函数如 `int()` 和 `float()` 转换成数字。但是如果字符串中包含非数字字符或格式不正确，这些转换函数可能会引发异常。因此，在将字符串转换为数字之前，最好先确保字符串的内容符合数字的格式和要求。
				- ### 浮点数转整数会丢失什么？
				  collapsed:: true
					- 浮点数转整数时会丢失小数部分的数值，只保留整数部分。例如，将浮点数3.14转换为整数时，会丢失小数点后面的14，只保留3。这是因为整数类型不能存储小数，只能存储整数。如果需要保留小数，就需要使用浮点数类型。
			- ## 第六节 标识符
			  collapsed:: true
				- ### python中什么是标识符？
				  collapsed:: true
					- 在Python中，标识符是开发人员自定义的名称，用来标识变量、函数、类、模块等对象。标识符必须遵守一些规则，如只能包含字母、数字、下划线等字符，不能以数字开头，不能与Python保留关键字重复等。合法的标识符在Python中具有唯一性，可以用于引用代码中定义的对象。
				- ### python标识符命名规则
				  collapsed:: true
					- Python标识符是指用于标识变量、函数、类等命名的字符序列。在Python中，标识符的命名规则如下：
					  
					  1. 由字母（包括大写和小写）、数字和下划线组成，不支持其他特殊字符；
					  2. 不能以数字开头；
					  3. 区分大小写；
					  4. 不能使用Python的关键字（例如if、while等）作为标识符；
					  5. 建议使用有意义的单词或短语作为标识符；
					  6. 一般使用小写字母命名变量和函数，使用大写字母命名类；
					  7. 若标识符由多个单词组成，可以使用下划线将单词分隔开（例如my_variable）。
					   
					  以下是Python关键字列表：
					  ```
					  and       exec      not
					  as        finally   or
					  assert    for       pass
					  break     from      print
					  class     global    raise
					  continue  if        return
					  def       import    try
					  del       in        while
					  elif      is        with
					  else      lambda    yield
					  except
					  ```
				- ### python变量命名的规范
				  collapsed:: true
					- Python变量命名的规范包括以下几点：
					  
					  1. 变量名只能包含字母、数字和下划线，不能以数字开头。
					  2. 变量名应该尽量简洁，但不应太过简略以至于难以理解。
					  3. 变量名应该有意义，能够反映出该变量所代表的内容。
					  4. 多个单词组成的变量名，可以用下划线（Snake Case）或者驼峰式（Camel Case）来连接单词，建议采用Snake Case，即下划线连接。
					  5. 避免使用Python保留字（如if、else、for、while等）作为变量名。
					  6. 变量名要注意大小写，Python是区分大小写的，因此Test和test是不同的变量名。
					  7. 变量名要做到见名知意，在变量名中应该使用一些简单、易懂、能够表达出变量含义的单词，避免过于复杂的缩写。
			- ## 第七节 运算符
			  collapsed:: true
				- ### python算术运算符
				  collapsed:: true
					- Python中的算术运算符包括加法运算符（+）、减法运算符（-）、乘法运算符（ * ）、除法运算符（/）、取余运算符（%）、幂运算符（* *），以及取整除运算符（//）。这些运算符可以用于执行常规算术操作，例如相加、相减、相乘和相除。您可以将这些运算符应用于数字（整数，浮点数等），以便执行相应的操作来实现所需的结果。例如，使用加法运算符可以将两个数字相加，并使用乘法运算符将其相乘。
				- ### python 赋值运算符
				  collapsed:: true
					- 在 Python 中，赋值运算符用于给变量赋值。常用的赋值运算符包括：
					- 等号（=）：将等号右侧的值赋给等号左侧的变量。
					  加等于（+=）：在变量原有的值基础上加上等号右侧的值，并将结果赋给等号左侧的变量。
					  减等于（-=）：在变量原有的值基础上减去等号右侧的值，并将结果赋给等号左侧的变量。
					  乘等于（*=）：将变量原有的值乘以等号右侧的值，并将结果赋给等号左侧的变量。
					  除等于（/=）：将变量原有的值除以等号右侧的值，并将结果赋给等号左侧的变量。
					  模等于（%=）：将变量原有的值对等号右侧的值取模运算，并将结果赋给等号左侧的变量。
					- 幂等于（**=）：将变量原有的值求幂值，幂值为等号右侧的值，并将结果赋给等号左侧的变量。
				-
			- ##  第八节 字符串拓展
			  collapsed:: true
				- ### 字符串的三种定义方式
				  collapsed:: true
					- 在大多数编程语言中，字符串可以通过以下三种方式定义：
					  
					  1. 用双引号或单引号括起来的字符序列。例如，"Hello, World!" 或 'This is a string.'。
					  
					  2. 用三个双引号或单引号括起来的多行字符串。例如：
					  
					  ```
					  """This is a string
					  that spans
					  multiple lines."""
					  ```
					  
					  3. 通过字符串构造函数创建字符串。例如，在Python中，可以使用`str()`或`str.format()`函数创建字符串。
				- ### 引号的嵌套
					- 在 Python 中，我们可以使用单引号或双引号来表示字符串。如果需要在字符串中包含引号，则可以在外部使用一种引号，内部使用另一种引号。例如：
					  
					  ```
					  my_str = "He said, 'Hello world!'"
					  ```
					  
					  在上面的示例中，外部使用的是双引号，内部使用的是单引号。
					  
					  另一种方法是在需要嵌套的引号前面加上反斜杠（\），这样 Python 就会将该引号视为字符串的一部分。例如：
					  
					  ```
					  my_str = 'He said, "Hello world!"'
					  ```
					  
					  在上面的示例中，需要嵌套的引号是双引号，所以我们在其前面加上了反斜杠。\
				- ### 字符串拼接
				  collapsed:: true
					- 在Python中，可以使用加号（+）运算符将不同的字符串拼接起来。例如：
					  
					  ```python
					  s1 = 'Hello'
					  s2 = 'World'
					  result = s1 + s2
					  print(result)  # 输出：HelloWorld
					  ```
					  
					  也可以使用字符串的join方法，它是一个标准库中的方法，可以用来连接序列中的所有元素。例如：
					  
					  ```python
					  strings = ['Hello', 'World']
					  result = ''.join(strings)
					  print(result)  # 输出：HelloWorld
					  ```
					  
					  可以在join方法中传递一个分隔符，用于在拼接字符串时添加分隔符。例如：
					  
					  ```python
					  strings = ['Alice', 'Bob', 'Charlie']
					  separator = ', '
					  result = separator.join(strings)
					  print(result)  # 输出：Alice, Bob, Charlie
					  ```
				- ### 字符串格式化
				  collapsed:: true
					- 字符串格式化是一种将变量的值插入到字符串中特定位置的方式，使字符串更具可读性。它可以让我们以一种更直观的方式组合数据和文本。在Python中，格式化字符串有多种方式可以实现，如旧式格式化、新式格式化和最新的f-string格式化。其中，f-string是Python 3.6版本引入的，是最简洁、最易读、最流行的格式化方式之一。例如，
					  
					  ```
					  name = "Peter"
					  age = 35
					  message = f"My name is {name} and I'm {age} years old."
					  print(message)
					  ```
					  
					  这个代码段中，f-string是通过在字符串前加一个“f”来创建的。在大括号中，我们可以指定要插入的变量名，以及可选的格式说明符，以控制输出的格式。这使得代码更加简洁、易读和易于维护。
				- ### 字符串格式化的语法
				  collapsed:: true
					- Python字符串格式化语法包括使用占位符和格式化操作符。常用的占位符包括：
					  
					  %s 字符串
					  %d 整数
					  %f 浮点数
					  %e 科学计数法表示的浮点数
					  %x 十六进制整数
					  
					  以该字符串作为例子：`"My name is %s and I'm %d years old."`
					  
					  使用占位符进行字符串格式化的语法如下：
					  
					  使用%s占位符替换字符串：`"My name is %s and I'm %d years old." % ("Alice", 25)`
					  使用%d占位符替换整数：`"My name is %s and I'm %d years old. " % ("Bob", 30)`
					  使用%f占位符替换浮点数：`"The temperature is %.2f degrees Celsius." % 25.5`
					  使用%e占位符替换科学计数法表示的浮点数：`"The population is about %e people." % 7894561230`
					  使用%x占位符替换十六进制整数：`"The color code is #%x." % 16777215`
					  
					  格式化操作符也可以用来进行字符串格式化，例如：
					  
					  使用{}和format()方法进行字符串格式化：`"My name is {} and I'm {} years old.".format("Alice", 25)`
					  使用{:d}进行整数格式化：`"My name is {} and I'm {:d} years old.".format("Bob", 30)`
					  使用{:f}进行浮点数格式化：`"The temperature is {:.2f} degrees Celsius.".format(25.5)`
					  使用{:e}进行科学计数法格式化：`"The population is about {:e} people.".format(7894561230)`
					  使用{:x}进行十六进制格式化：`"The color code is #{:x}.".format(16777215)`
				- ### 字符串格式化数字精度控制
				  collapsed:: true
					- 在 Python 中，可以使用字符串格式化的语法来控制数字的精度。这个语法使用格式符号来指示要格式化的值的类型和精度，然后使用引号将其包含在字符串中。
					  
					  以下是控制数字精度的格式符号：
					  
					  `%f`: 格式化为浮点数，可以用 `.n` 来控制小数位数，如 `%.2f` 表示保留两位小数；
					  `%e` 或 `%E`: 使用科学计数法表示浮点数；
					  `%g` 或 `%G`: 自动选取 `%f` 或 `%e` 中较短的形式来表示浮点数。
					  
					  例如，以下代码演示了如何使用字符串格式化来控制浮点数的精度：
					  
					  ```python
					  num = 3.1415926
					  print("%.2f" % num)   # 保留两位小数
					  print("%.4f" % num)   # 保留四位小数
					  print("%.1e" % num)   # 科学计数法表示
					  print("%.2g" % num)   # 自动选取形式
					  ```
					  
					  输出结果为：
					  
					  ```
					  3.14
					  3.1416
					  3.1e+00
					  3.1
					  ```
					- ![image.png](../assets/image_1684050942690_0.png)
					- ![image.png](../assets/image_1684051157468_0.png)
				- ### 什么是表达式
				  collapsed:: true
					-
					- 在Python中，表达式是由一个或多个值、运算符和函数调用组成的代码行，可以用来计算出一个值。例如，`2 + 3`、`3 * 4`、`abs(-5)`等都是Python中的表达式。表达式可以用于赋值、作为函数参数或作为条件判断语句的条件部分。同时，Python支持复杂的表达式，如使用条件表达式实现简单的if-else语句，使用lambda表达式定义匿名函数等。
				- ### 表达式怎么进行格式化
				  collapsed:: true
					- 在Python中，使用字符串格式化中表达式可以将变量的值插入到字符串中。表达式书写在大括号中，例如：
					  
					  ```
					  my_name = "Alice"
					  my_age = 25
					  print("My name is {}. I am {} years old.".format(my_name, my_age))
					  ```
					  
					  上面的代码将会输出：
					  
					  ```
					  My name is Alice. I am 25 years old.
					  ```
					  
					  你也可以在大括号中通过冒号指定输出格式，例如：
					  
					  ```
					  pi = 3.1415926
					  print("The value of pi is approximately {:.2f}.".format(pi))
					  ```
					  
					  上面的代码将会输出：
					  
					  ```
					  The value of pi is approximately 3.14.
					  ```
					  
					  在格式化表达式中，你还可以使用字符串填充方式，例如：0填充、宽度和左对齐等，具体可以查看Python官方文档。
				-
				-
				-
			- ## 第九节 数据输入
			  collapsed:: true
				- ### input语句的作用
				  collapsed:: true
					- 在Python中，`input()`函数用于从控制台或命令行获取用户输入的数据，并将其存储为 ^^字符串类型^^ 。该函数将等待用户输入，直到用户敲击Enter键为止。可以提供提示信息，以告诉用户需要输入什么类型的数据。
					  
					  `input()`函数的返回值为字符串类型，因此需要根据用户的输入进行必要的转换才能使用。例如，如果需要一个整数，就需要使用`int()`函数将输入的字符串转换为整数。同样地，如果需要一个浮点数，就需要使用`float()`函数将输入的字符串转换为浮点数。
				- ### input语句的使用
				  collapsed:: true
					- input语句是一种用于从用户处获取输入的Python函数，它通常用于交互式应用程序中。
					  
					  例如，下面的代码使用input函数提示用户输入他们的姓名，然后将输入值存储在变量name中：
					  
					  ```
					  name = input("请输入您的姓名：")
					  print("您好，" + name + "！")
					  ```
					  
					  当该代码在命令行中运行时，它会提示用户输入他们的姓名。如果用户输入“Tom”，则输出"您好，Tom！"
				-
	- **C语言**
	  collapsed:: true
		- # 第1章 初识C语言
		  id:: 64b90a23-508f-4efc-a17c-1f8687c6c5dd
		  collapsed:: true
			- ## C语言简介
			  collapsed:: true
				- C语言是一种通用的、面向过程的计算机编程语言。它是由贝尔实验室的Dennis Ritchie在20世纪70年代初开发的，用于开发系统软件和应用程序。C语言具有简洁、高效的特点，广泛应用于操作系统、编译器、嵌入式系统以及其他许多计算机应用领域。
				  
				  C语言提供了丰富的基本数据类型、控制结构和运算符，能够实现复杂的计算和逻辑操作。它还支持指针操作，使得在内存管理和数据结构上更加灵活。C语言也提供了丰富的标准库函数，用于各种输入、输出、字符串处理、内存分配等常见操作。
				  
				  由于C语言的简洁性和高效性，它成为了许多高级编程语言的基础，例如C++、Java和Python。学习C语言有助于理解计算机底层原理和编程的基本概念，为进一步学习其他编程语言打下良好的基础。
				  [C 简介 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-intro.html)
			- ## C语言优点
			  collapsed:: true
				- 1. 直接而强大的硬件访问能力：C语言提供了丰富的硬件访问函数和指令，可以直接操作底层硬件，实现高性能和高效率的程序设计。
				  
				  2. 可移植性强：C语言的语法规范相对简单，没有依赖于特定平台或操作系统的特性，因此可以很方便地进行程序移植。
				  
				  3. 高效的执行速度：C语言是一种编译型语言，程序在编译后直接转化为机器码执行，因此执行速度非常快。
				  
				  4. 丰富的标准库：C语言提供了丰富的标准库函数，包括输入输出、字符串处理、数学计算等功能，方便开发者进行程序开发。
				  
				  5. 应用广泛：C语言是一种通用的编程语言，广泛应用于操作系统、嵌入式系统、游戏开发等领域，具有较强的通用性和实用性。
				  
				  6. 可以与汇编语言相结合：C语言可以通过内联汇编等方式与汇编语言相结合，充分发挥硬件的特性，提高程序的性能。
				  
				  7. 适合系统级编程：C语言提供了丰富的内存和指针操作功能，非常适合进行系统级编程，如操作系统、驱动程序等开发。
				  
				  需要注意的是，C语言在一些方面也存在一些缺点，比如缺乏对面向对象编程的直接支持、易出现内存安全问题等。但是总体来说，C语言依然是一门非常强大和实用的编程语言。
			- ## 简单的C程序示例
			  collapsed:: true
				- 这是一个简单的C程序，它将打印出 "Hello, World!" 这个字符串。
				  
				  ```c
				  #include <stdio.h>
				  
				  int main() 
				  {
				      printf("Hello, World!\n");
				      return 0;
				  }
				  ```
				  
				  你可以将这段代码复制到C编译器中，并运行它来查看输出结果。输出应该是 "Hello, World!"。
			- ## C 关键字
			  collapsed:: true
				- C语言中有一些关键字，它们具有特殊的含义，用于控制程序的流程和实现特定的功能。以下是一些常见的C语言关键字：
				  
				  1. auto：用于声明自动变量，通常用于局部变量的定义。
				  2. break：用于跳出循环或switch语句块。
				  3. case：用于定义switch语句中的分支条件。
				  4. const：用于定义常量，表示其值不能被修改。
				  5. continue：用于跳过当前循环的剩余部分，并继续下一轮循环。
				  6. default：用于定义switch语句中的默认分支。
				  7. do：用于开始一个do-while循环。
				  8. double：用于声明双精度浮点型变量。
				  9. else：用于定义if语句中条件不成立时的执行代码块。
				  10. enum：用于定义枚举类型，它是一种具有一组取值的特殊数据类型。
				  11. extern：用于声明全局变量或函数，表示其定义在其他文件中。
				  12. float：用于声明单精度浮点型变量。
				  13. for：用于创建一个for循环。
				  14. goto：用于无条件地转移到程序中的指定标签。
				  15. if：用于进行条件判断，执行满足条件的代码块。
				  16. int：用于声明整型变量。
				  17. long：用于声明长整型变量。
				  18. register：用于声明寄存器变量，通常用于对频繁访问的变量进行优化。
				  19. return：用于从函数中返回值。
				  20. short：用于声明短整型变量。
				  21. signed：用于声明有符号整型变量。
				  22. sizeof：用于获取数据类型或变量所占用的字节数。
				  23. static：用于声明静态变量，表示其生存期贯穿整个程序的执行过程。
				  24. struct：用于定义结构体类型，可以将多个不同类型的数据组织在一起。
				  25. switch：用于创建一个多分支选择结构。
				  26. typedef：用于给数据类型取别名。
				  27. union：用于定义联合类型，可以在同一段内存中存储多种数据类型。
				  28. unsigned：用于声明无符号整型变量。
				  29. void：用于声明无返回值或不带参数的函数。
				  30. volatile：用于声明易变的，可能会被意外改变的变量。
				  
				  这些关键字在C语言中有特殊的用途和含义，遵循特定的语法和规则来使用。
				  [C语言32个关键字-最详解释_c语言关键字_二马路的博客-CSDN博客](https://blog.csdn.net/qq_38972634/article/details/108398953)
			- ## C 数据类型
			  collapsed:: true
				- C语言中有多种数据类型，每种数据类型对应不同的值和操作。下面是C语言中常见的一些数据类型：
				  
				  1. 整型（Integer）：用来表示整数。包括以下几种类型：
				     char：1字节，表示字符或小整数。
				     short：2字节，表示短整数。
				     int：通常为4字节，表示整数。
				     long：4或8字节，表示长整数。
				     long long：8字节，表示更长的整数。                                                                                                                                        
				   2. 浮点型（Floating point）：用来表示带有小数部分的数值。包括以下几种类型：
				     float：4字节，表示单精度浮点数。  
				     double：8字节，表示双精度浮点数。  
				     long double：通常为10或12字节，表示更高精度的浮点数。  
				  
				  3. 字符型（Character）：用来表示单个字符。通常使用char类型。  
				  4. 字符串型（String）：用来表示一串字符。实际上是字符数组，以空字符'\0'结尾。  
				  5. 布尔型（Boolean）：用来表示逻辑值，只包括两种值true和false。在C语言中，通常使用int类型的0表示false，非零值表示true。  
				  6. 指针型（Pointer）：用来表示内存地址。指针可以指向不同的数据类型，并且可以通过指针来访问和修改对应的内存中的值。  
				  7. 结构体型（Structure）：用来表示由不同数据类型组合而成的结构体。结构体可以包含多个不同的成员，并且可以通过成员访问运算符"."来访问结构体的成员。  
				  8. 枚举型（Enumeration）：用来表示一组具有离散值的常量。通过定义枚举类型，可以为每个常量赋予一个特定的整数值。  
				  
				  除了上述基本的数据类型，C语言还允许通过类型定义（typedef）来创建自定义的数据类型，以满足特定的需求。
				  [C 数据类型 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-data-types.html)
				-
			- ## C 操作符
			  collapsed:: true
				- ### 算术运算符
				  collapsed:: true
					- | 运算符 | 描述            | 实例                   |
					  | --- | ------------- | -------------------- |
					  | +   | 加法运算符,相加操作数   | a + b 输出a和b的和        |
					  | -   | 减法运算符,相减操作数   | a - b 输出a减去b的值       |
					  | \*  | 乘法运算符,相乘操作数   | a * b 输出a和b相乘之积      |
					  | /   | 除法运算符,相除操作数   | a / b 输出a除以b的商       |
					  | %   | 取模运算符,取余数     | a % b 输出a除以b的余数      |
					  | ++  | 自增运算符,使操作数值增1 | a++ 将a增加1            |
					  | --  | 自减运算符,使操作数值减1 | a-- 将a减少1            |
					  *实例*
					  ```c
					  #include <stdio.h>
					   
					  int main()
					  {
					     int a = 21;
					     int b = 10;
					     int c ;
					   
					     c = a + b;
					     printf("Line 1 - c 的值是 %d\n", c );
					     c = a - b;
					     printf("Line 2 - c 的值是 %d\n", c );
					     c = a * b;
					     printf("Line 3 - c 的值是 %d\n", c );
					     c = a / b;
					     printf("Line 4 - c 的值是 %d\n", c );
					     c = a % b;
					     printf("Line 5 - c 的值是 %d\n", c );
					     c = a++;  // 赋值后再加 1 ，c 为 21，a 为 22
					     printf("Line 6 - c 的值是 %d\n", c );
					     c = a--;  // 赋值后再减 1 ，c 为 22 ，a 为 21
					     printf("Line 7 - c 的值是 %d\n", c );
					   
					  }
					  ```
					- %运算符,也称取模运算符,它用于计算两个操作数的除法的余数。
					  使用%运算符时,有以下几点要求:
					  1. 两个操作数都必须是整数类型,不能是小数或者浮点数。如sizeof、int等整型都可以,double、float不可以。
					  2. 除数不能为0。因为整数除以0是没有意义的,会导致运行时错误。
					  3. 结果也是整数类型。无论原操作数是什么类型,结果都为非负整数。
					  4. 它采用整除法则,也就是ignoring小数部分,只保留整数部分。
					- #### ^^++和--前置和后置的区别^^
					  ```c
					  #include <stdio.h>
					   
					  int main()
					  {
					     int c;
					     int a = 10;
					     c = a++; 
					     printf("先赋值后运算：\n");
					     printf("Line 1 - c 的值是 %d\n", c );
					     printf("Line 2 - a 的值是 %d\n", a );
					     a = 10;
					     c = a--; 
					     printf("Line 3 - c 的值是 %d\n", c );
					     printf("Line 4 - a 的值是 %d\n", a );
					   
					     printf("先运算后赋值：\n");
					     a = 10;
					     c = ++a; 
					     printf("Line 5 - c 的值是 %d\n", c );
					     printf("Line 6 - a 的值是 %d\n", a );
					     a = 10;
					     c = --a; 
					     printf("Line 7 - c 的值是 %d\n", c );
					     printf("Line 8 - a 的值是 %d\n", a );
					   
					  }
					  ````
					  运算结果
					  ```
					  先赋值后运算：
					  Line 1 - c 的值是 10
					  Line 2 - a 的值是 11
					  Line 3 - c 的值是 10
					  Line 4 - a 的值是 9
					  先运算后赋值：
					  Line 5 - c 的值是 11
					  Line 6 - a 的值是 11
					  Line 7 - c 的值是 9
					  Line 8 - a 的值是 9
					  ````
						- ^a++ 与 ++a 的区
				- ### 关系运算符
				  collapsed:: true
					- | 运算符 | 描述    | 实例                           |
					  | --- | ----- | ---------------------------- |
					  | ==  | 等于    | (a == b) 如果 a 等于 b 则条件为真     |
					  | !=  | 不等于   | (a != b) 如果 a 不等于 b 则条件为真    |
					  | >   | 大于    | (a > b) 如果 a 大于 b 则条件为真      |
					  | \<  | 小于    | (a \< b) 如果 a 小于 b 则条件为真     |
					  | >=  | 大于或等于 | (a >= b) 如果 a 大于或等于 b 则条件为真  |
					  | \<= | 小于或等于 | (a \<= b) 如果 a 小于或等于 b 则条件为真 |
					  *实例*
					  ```C
					  #include <stdio.h>
					   
					  int main()
					  {
					     int a = 21;
					     int b = 10;
					     int c ;
					   
					     if( a == b )
					     {
					        printf("Line 1 - a 等于 b\n" );
					     }
					     else
					     {
					        printf("Line 1 - a 不等于 b\n" );
					     }
					     if ( a < b )
					     {
					        printf("Line 2 - a 小于 b\n" );
					     }
					     else
					     {
					        printf("Line 2 - a 不小于 b\n" );
					     }
					     if ( a > b )
					     {
					        printf("Line 3 - a 大于 b\n" );
					     }
					     else
					     {
					        printf("Line 3 - a 不大于 b\n" );
					     }
					     /* 改变 a 和 b 的值 */
					     a = 5;
					     b = 20;
					     if ( a <= b )
					     {
					        printf("Line 4 - a 小于或等于 b\n" );
					     }
					     if ( b >= a )
					     {
					        printf("Line 5 - b 大于或等于 a\n" );
					     }
					  }
					  ````
					  *当上面的代码被编译和执行时，它会产生下列结果：*
					  ```
					  Line 1 - a 不等于 b
					  Line 2 - a 不小于 b
					  Line 3 - a 大于 b
					  Line 4 - a 小于或等于 b
					  Line 5 - b 大于或等于 a
					  ````
				- ### 逻辑运算符
				  collapsed:: true
					- | 运算符  | 描述       | 实例                                |
					  | ----           | -------- | --------------------------------- |
					  | &&           | 逻辑与运算符   | (a && b) 如果 a 和 b 都为真,则条件为真       |
					  | II  | 逻辑或运算符   | (a II b) 如果 a 和 b 至少有一个为真,则条件为真 |
					  | !               | 逻辑非运算符   | !(a && b) 将条件的真假值取反               |
					  *注I是竖线，markdown转义不了*
					  *实例*
					  ```c
					  #include <stdio.h>
					   
					  int main()
					  {
					     int a = 5;
					     int b = 20;
					     int c ;
					   
					     if ( a && b )
					     {
					        printf("Line 1 - 条件为真\n" );
					     }
					     if ( a || b )
					     {
					        printf("Line 2 - 条件为真\n" );
					     }
					     /* 改变 a 和 b 的值 */
					     a = 0;
					     b = 10;
					     if ( a && b )
					     {
					        printf("Line 3 - 条件为真\n" );
					     }
					     else
					     {
					        printf("Line 3 - 条件为假\n" );
					     }
					     if ( !(a && b) )
					     {
					        printf("Line 4 - 条件为真\n" );
					     }
					  }
					  ````
					  *结果*
					  ````
					  Line 1 - 条件为真
					  Line 2 - 条件为真
					  Line 3 - 条件为假
					  Line 4 - 条件为真
					  ````
				- ### 位运算符
				  collapsed:: true
					- 假设变量 **A** 的值为 60，变量 **B** 的值为 13，则：
					  | 运算符 | 描述  | 实例                  |
					  | &      | 对两个操作数的每一位执行逻辑与操作，如果两个相应的位都为 1，则结果为 1，否则为 0。                          | (A & B) 将得到 12，即为 0000 1100    |
					  | I     | 对两个操作数的每一位执行逻辑或操作，如果两个相应的位都为 0，则结果为 0，否则为 1。                          | (A I B) 将得到 61，即为 0011 1101    |
					  | ^      | 对两个操作数的每一位执行逻辑异或操作，如果两个相应的位值相同，则结果为 0，否则为 1。                          | (A ^ B) 将得到 49 ，即为 0011 0001    |
					  | ~      | 对操作数的每一位执行逻辑取反操作，即将每一位的 0 变为 1，1 变为 0。                                          | (~A ) 将得到 -61 ，即为 1100 0011，一个有符号二进制数的补码形式。    |
					  | <<     | 将操作数的所有位向左移动指定的位数。左移 n 位相当于乘以 2 的 n 次方。二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。                                        | A << 2 将得到 240，即为 1111 0000    |
					  | >>     | 将操作数的所有位向右移动指定的位数。右移 n 位相当于除以 2 的 n 次方。二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。                                        | A >> 2 将得到 15，即为 0000 1111     |
					  *注1是竖线，markdown转义不了*
					  *实例*
					  ```c
					  #include <stdio.h>
					   
					  int main()
					  {
					   
					     unsigned int a = 60;    /* 60 = 0011 1100 */  
					     unsigned int b = 13;    /* 13 = 0000 1101 */
					     int c = 0;           
					   
					     c = a & b;       /* 12 = 0000 1100 */ 
					     printf("Line 1 - c 的值是 %d\n", c );
					   
					     c = a | b;       /* 61 = 0011 1101 */
					     printf("Line 2 - c 的值是 %d\n", c );
					   
					     c = a ^ b;       /* 49 = 0011 0001 */
					     printf("Line 3 - c 的值是 %d\n", c );
					   
					     c = ~a;          /*-61 = 1100 0011 */
					     printf("Line 4 - c 的值是 %d\n", c );
					   
					     c = a << 2;     /* 240 = 1111 0000 */
					     printf("Line 5 - c 的值是 %d\n", c );
					   
					     c = a >> 2;     /* 15 = 0000 1111 */
					     printf("Line 6 - c 的值是 %d\n", c );
					  }
					  ````
					  *结果*
					  ````
					  Line 1 - c 的值是 12
					  Line 2 - c 的值是 61
					  Line 3 - c 的值是 49
					  Line 4 - c 的值是 -61
					  Line 5 - c 的值是 240
					  Line 6 - c 的值是 15
					  ````
				- ### 赋值运算符
				  collapsed:: true
					- |运算符   | 描述       | 实例                         |
					  | ----- | -------- | -------------------------- |
					  | =     | 简单赋值运算符  | a = b 将b的值赋给a              |
					  | +=    | 加法赋值运算符  | a += b 等同于 a = a + b       |
					  | -=    | 减法赋值运算符  | a -= b 等同于 a = a - b       |
					  | \*=   | 乘法赋值运算符  | a \*= b 等同于 a = a * b      |
					  | /=    | 除法赋值运算符  | a /= b 等同于 a = a / b       |
					  | %=    | 取模赋值运算符  | a %= b 等同于 a = a % b       |
					  | &=    | 位与赋值运算符  | a &= b 等同于 a = a & b       |
					  | ^=    | 位异或赋值运算符 | a ^= b 等同于 a = a ^ b       |
					  | \<\<= | 左移赋值运算符  | a \<\<= 2 等同于 a = a \<\< 2 |
					  | >>=   | 右移赋值运算符  | a >>= 2 等同于 a = a >> 2     |
					  *实例*
					  ```c
					  #include <stdio.h>
					   
					  int main()
					  {
					     int a = 21;
					     int c ;
					   
					     c =  a;
					     printf("Line 1 - =  运算符实例，c 的值 = %d\n", c );
					   
					     c +=  a;
					     printf("Line 2 - += 运算符实例，c 的值 = %d\n", c );
					   
					     c -=  a;
					     printf("Line 3 - -= 运算符实例，c 的值 = %d\n", c );
					   
					     c *=  a;
					     printf("Line 4 - *= 运算符实例，c 的值 = %d\n", c );
					   
					     c /=  a;
					     printf("Line 5 - /= 运算符实例，c 的值 = %d\n", c );
					   
					     c  = 200;
					     c %=  a;
					     printf("Line 6 - %%= 运算符实例，c 的值 = %d\n", c );
					   
					     c <<=  2;
					     printf("Line 7 - <<= 运算符实例，c 的值 = %d\n", c );
					   
					     c >>=  2;
					     printf("Line 8 - >>= 运算符实例，c 的值 = %d\n", c );
					   
					     c &=  2;
					     printf("Line 9 - &= 运算符实例，c 的值 = %d\n", c );
					   
					     c ^=  2;
					     printf("Line 10 - ^= 运算符实例，c 的值 = %d\n", c );
					   
					     c |=  2;
					     printf("Line 11 - |= 运算符实例，c 的值 = %d\n", c );
					   
					  }
					  ````
					  *结果*
					  ````
					  Line 1 - =  运算符实例，c 的值 = 21
					  Line 2 - += 运算符实例，c 的值 = 42
					  Line 3 - -= 运算符实例，c 的值 = 21
					  Line 4 - *= 运算符实例，c 的值 = 441
					  Line 5 - /= 运算符实例，c 的值 = 21
					  Line 6 - %= 运算符实例，c 的值 = 11
					  Line 7 - <<= 运算符实例，c 的值 = 44
					  Line 8 - >>= 运算符实例，c 的值 = 11
					  Line 9 - &= 运算符实例，c 的值 = 2
					  Line 10 - ^= 运算符实例，c 的值 = 0
					  Line 11 - |= 运算符实例，c 的值 = 2
					  ````
				- ### 杂项运算符
				  collapsed:: true
					- |运算符	|描述	|实例|
					  |sizeof()	|返回变量的大小。|	sizeof(a) 将返回 4，其中 a 是整数。|
					  |&	|返回变量的地址。	|&a; 将给出变量的实际地址。|
					  |*	|指向一个变量。|	*a; 将指向一个变量。|
					  |? :	|条件表达式|	如果条件为真 ? 则值为 X : 否则值为 Y|
					  *实例*
					  ```c
					  #include <stdio.h>
					  
					  int main()
					  {
					   int a = 4;
					   short b;
					   double c;
					   int* ptr;
					  
					   /* sizeof 运算符实例 */
					   printf("Line 1 - 变量 a 的大小 = %lu\n", sizeof(a) );
					   printf("Line 2 - 变量 b 的大小 = %lu\n", sizeof(b) );
					   printf("Line 3 - 变量 c 的大小 = %lu\n", sizeof(c) );
					  
					   /* & 和 * 运算符实例 */
					   ptr = &a;    /* 'ptr' 现在包含 'a' 的地址 */
					   printf("a 的值是 %d\n", a);
					   printf("*ptr 是 %d\n", *ptr);
					  
					   /* 三元运算符实例 */
					   a = 10;
					   b = (a == 1) ? 20: 30;
					   printf( "b 的值是 %d\n", b );
					  
					   b = (a == 10) ? 20: 30;
					   printf( "b 的值是 %d\n", b );
					  }
					  ````
					  *结果*
					  ````
					  Line 1 - 变量 a 的大小 = 4
					  Line 2 - 变量 b 的大小 = 2
					  Line 3 - 变量 c 的大小 = 8
					  a 的值是 4
					  *ptr 是 4
					  b 的值是 30
					  b 的值是 20
					  ````
				- [C 运算符 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-operators.html)
			- ## C 占位符
			  collapsed:: true
				- ### 初阶占位符
				  collapsed:: true
					- C语言中的占位符是指在格式化输出中使用的特殊符号，用来表示要输出或接收的数据类型。常用的C语言占位符如下：
					- `%d`：用来输出或接收整数类型的数据。
					  `%f`：用来输出或接收浮点数类型的数据。
					  `%c`：用来输出或接收字符类型的数据。
					  `%s`：用来输出或接收字符串类型的数据。
					  `%p`：用来输出指针类型的数据。
					  `%ld`：用来输出或接收长整型类型的数据。
					  `%lu`：用来输出或接收无符号长整型类型的数据。
					  `%lf`：用来输出或接收双精度浮点数类型的数据。
					  `%x`：用来输出或接收十六进制整数类型的数据。
					  `%o`：用来输出或接收八进制整数类型的数据。
					  在使用这些占位符时，我们通常会配合其他参数，比如变量或常量，来完成相应的输入输出操作。例如，使用`printf`函数来输出整数类型的数据：
					  ```c
					  int num = 10;
					  printf("The number is: %d", num);
					  ```
					  这段代码中，`%d`是占位符，表示要输出的是一个整数类型的数据，`num`是要输出的整数变量。
				- ### 进阶占位符
				  collapsed:: true
					- `%06f `- 用来格式化浮点数,实现6位有效数字及小数点前后对齐。
					  ``%10s ``- 用来格式化字符串,保证字符串总长度为10个字符,内容右对齐。
					  ``%010x`` - 用来格式化16进制整数,至少10位字符宽度,高位用0填充。
					  ``%-10s ``- 左对齐10个字符宽度的字符串。
					  还有一些格式可以结合使用:
					  ``%.2f`` - 格式化浮点数,保留2位小数。
					  ``%10.4f`` - 浮点数整个字段宽度10字符,小数点后4位。
					  ``%+06d`` - 整数采用正负号与数值组合显示,宽度6位数。
					  所以通过组合数字宽度字段、小数精度、对齐符等格式控制键,可以非常灵活地对不同类型的数据进行格式化输出。这在输出带格式报告或对齐对人阅读更友好的场景下很有用。
					- 这里有一些使用不同格式化指示符的示例:
					  1.格式化浮点数:
					  ```c
					  float num = 3.141592;
					  printf("%.2f\n", num); // 输出小数后两位 3.14
					  ```
					  2.格式化字符串:
					  ```c 
					  char str[] = "Hello";
					  printf("%10s\n", str); // 输出字符串,宽度10字符,右对齐 
					                        // 输出 "     Hello"
					  ```
					  3.格式化16进制整数:
					  ```c
					  int hex = 0xFF;
					  printf("%#010x\n", hex); // 输出16进制数,宽度10字符,高位用0填充
					                        // 输出 "0x000000ff"  
					  ```
					  4.格式化带符号整数:
					  ```c
					  int dec = 10; 
					  printf("%+06d\n", dec); // 正负号与整数组合显示,宽度6位
					                        // 输出 "+000010"
					  ```
					  5.格式化浮点数带单位:
					  ```c
					  float value = 1.5;
					  printf("%.1f kg\n", value); // 小数一位,带单位kg
					                        // 输出 "1.5 kg"
					  ```
					  这些示例演示了格式化指示符如何控制输出格式、宽度和对齐方式。控制得当可以让输出更友好美观。
			- ## C 转义字符
			  collapsed:: true
				- C语言中的转义字符用于表示一些特殊的字符，以反斜杠（\）开头。下面是一些常见的C语言转义字符：
				  
				  |转义字符	|意义	|ASCII码值（十进制）|
				  | \\a	|响铃(BEL)	|007|
				  | \\b	|退格(BS) ，将当前位置移到前一列	|008|
				  | \\f	|换页(FF)，将当前位置移到下页开头	|012|
				  |\\n	|换行(LF) ，将当前位置移到下一行开头	|010|
				  |\\r	|回车(CR) ，将当前位置移到本行开头	|013|
				  |\\t	|水平制表(HT) （跳到下一个TAB位置）	|009|
				  |\\v	|垂直制表(VT)	|011|
				  |\\\	|代表一个反斜线字符''\\''	|092|
				  |\\'	|代表一个单引号（撇号）字符	|039|
				  |\\"	|代表一个双引号字符	|034|
				  |\\0	|空字符(NULL)	|000|
				  |\\ddd	|1到3位八进制数所代表的任意字符	|三位八进制|
				  |\\xhh	|1到2位十六进制所代表的任意字符	|二位十六进制|
				  
				  使用转义字符可以在字符串中插入特殊字符，例如：
				  
				  ```c
				  printf("Hello\nWorld");   // 输出：Hello
				                            //        World
				  printf("This is a\ttab");  // 输出：This is a    tab
				  printf("I am quoting a \"");   // 输出：I am quoting a "
				  ```
				  
				  注意，转义字符只能在字符常量和字符串常量中使用。
				  [附录*转义字符 - C 语言笔记 (gitbook.io)](https://xiaoxiami.gitbook.io/c/zhuan-yi-zi-fu-he-kong-bai-fu)
			- ## C 注释
			  collapsed:: true
				- C语言注释是在代码中添加的一种说明文本，它不会被编译器处理，只是用来帮助程序员理解代码和做注解。通常，注释用于解释代码的功能、输入/输出、变量定义、算法等，以提高代码的可读性和可维护性。
				  
				  在C语言中，有两种常见的注释方式：
				  
				  1. 单行注释：以双斜杠（//）开头，从开头处开始，到行末结束的所有内容都被视为注释。例如：
				  
				  ```c
				  // 这是一个单行注释
				  ```
				  
				  2. 多行注释：以斜杠星号（/* ）开头，以星号斜杠（ */）结尾，之间的所有内容都被视为注释。^^不支持嵌套注释^^，例如：
				  
				  ```c
				  /*
				  这是一个多行注释
				  它可以跨越多行
				  */
				  ```
				  
				  注释可以在任何位置添加，通常放在代码的关键部分，用来解释复杂操作或者提醒其他程序员。注释对于自己或其他开发者来说都是非常有用的，可以提供关键信息，便于代码的理解和维护。在编写代码时，建议经常使用注释，并且使注释保持与代码的同步更新，以便更好地组织和解释代码。
			- ## 定义变量的方法
			  collapsed:: true
				- 在C语言中，可以使用以下方法定义变量：
				  
				  1. 使用基本数据类型定义变量：C语言提供了多种基本数据类型，包括整型、字符型、浮点型等。可以通过指定数据类型和变量名称来定义变量，例如：
				     ```c
				     int age; // 定义一个整型变量age
				     char grade; // 定义一个字符型变量grade
				     float salary; // 定义一个浮点型变量salary
				     ```
				  
				  2. 使用关键字`typedef`定义别名：使用`typedef`关键字可以给已有的数据类型定义一个新的名字，从而更方便地使用该类型。例如：
				     ```c
				     typedef int Number; // 将int类型定义为Number类型
				     Number num; // 定义一个Number类型的变量num，实际上是int类型的变量
				     ```
				  
				  3. 使用结构体定义复合类型的变量：结构体可以用于定义包含多个不同类型成员的复合类型。通过使用关键字`struct`和结构体名称来定义结构体，并在结构体内部定义各个成员变量。例如：
				  
				     ```c
				     struct person 
				     {
				         char name[20];
				         int age;
				     };
				  
				     struct person p1; // 定义一个person类型的结构体变量p1
				  ```
				  
				  4. 使用枚举类型定义符号常量：枚举类型用于定义一组具有名称的符号常量，可以提高程序的可读性。通常使用`enum`关键字定义枚举类型，并在大括号内列出枚举常量。例如：
				  
				     ```c
				     enum colors 
				     {
				         RED,
				         GREEN,
				         BLUE
				     };
				  
				     enum colors color; // 定义一个colors类型的变量color
				  ```
				  
				  需要注意的是，变量定义必须在使用之前进行，且变量的定义可以包括初始化赋值，也可以在稍后进行赋值操作。
				  [C 变量 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-variables.html)
			- ## 变量的分类
			  collapsed:: true
				- ### 1.局部变量 -{}内部定义的
				  在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。
				  ```c
				  #include <stdio.h>
				   
				  int main ()
				  {
				    /* 局部变量声明 */
				    int a, b;
				    int c;
				   
				    /* 实际初始化 */
				    a = 10;
				    b = 20;
				    c = a + b;
				   
				    printf ("value of a = %d, b = %d and c = %d\n", a, b, c);
				   
				    return 0;
				  }
				  ````
				  当局部变量和全局变量名字冲突的情况下，局部优先。不建议把全局变量和局部变量名字写成一样。
				- ### 2.全局变量 -{}外部定义的
				  全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例：
				  ```c
				  #include <stdio.h>
				   
				  /* 全局变量声明 */
				  int g;
				   
				  int main ()
				  {
				    /* 局部变量声明 */
				    int a, b;
				   
				    /* 实际初始化 */
				    a = 10;
				    b = 20;
				    g = a + b;
				   
				    printf ("value of a = %d, b = %d and g = %d\n", a, b, g);
				   
				    return 0;
				  }
				  ````
				- 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。下面是一个实例：
				  在程序中，局部变量和全局变量的
				  ```c
				  #include <stdio.h>
				   
				  /* 全局变量声明 */
				  int g = 20;
				   
				  int main ()
				  {
				    /* 局部变量声明 */
				    int g = 10;
				   
				    printf ("value of g = %d\n",  g);
				   
				    return 0;
				  }
				  ````
				  当上面的代码被编译和执行时，它会产生下列结果：
				  ```
				  value of g = 10
				  ```
				- [C 作用域规则 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-scope-rules.html)
			- ## 变量的作用域和生命周期
			  collapsed:: true
				- 在C语言中，变量的作用域和生命周期是两个相互关联的概念。
				  
				  作用域指的是一个变量在程序中可见的范围。一个变量可以有不同的作用域，包括全局作用域和局部作用域。
				  
				  ^^全局作用域^^ 的变量在整个程序中都可见和访问。这意味着它们可以在程序的任何地方使用。全局变量通常在程序的开始部分定义，在整个程序的执行过程中保持存在。
				  
				  ^^局部作用域^^的变量只在特定的代码块或函数中可见和访问。它们的作用域仅限于定义它们的代码块或函数的范围内。当代码块或函数执行结束后，局部变量将不再存在。
				  
				  变量的生命周期指的是变量在程序执行期间存在的时间段。全局变量的生命周期通常与程序的生命周期相同，它们在整个程序执行期间存在。局部变量的生命周期取决于它们所在的代码块或函数的执行时间。当代码块或函数结束执行时，局部变量的生命周期也就结束了。
				  
				  值得注意的是，全局变量和静态变量都具有静态存储期，这意味着它们的生命周期在程序的整个执行期间都会持续存在。局部变量和动态分配的内存（使用malloc等函数分配的内存）具有自动存储期，它们的生命周期取决于它们所在的代码块或函数的执行时间。
				  
				  了解变量的作用域和生命周期对于正确地使用变量以及避免命名冲突和内存泄漏等问题非常重要。
				- C语言中，变量的作用域定义了变量在程序中可见的范围，而变量的生命周期则指的是变量的存活时间。
				  
				  举一个例子来说明变量的作用域和生命周期：
				  
				  ```c
				  #include <stdio.h>
				  
				  void function1() 
				  {
				      int x = 10;  // 局部变量x
				      printf("x = %d\n", x);
				  }
				  
				  void function2() 
				  {
				      // x在此函数中不可见
				      printf("This is function2\n");
				  }
				  
				  int main() 
				  {
				      int x = 5;  // 主函数中的局部变量x
				      printf("x = %d\n", x);
				  
				      function1();  // 调用function1函数打印局部变量x的值
				  
				      {
				          int x = 7;  // 块作用域内的局部变量x
				          printf("x = %d\n", x);
				      }
				  
				      function2();  // 调用function2函数
				  
				      printf("x = %d\n", x);  // 打印主函数中的局部变量x的值
				  
				      return 0;
				  }
				  ```
				  *输出示例*
				  ```
				  x = 5
				  x = 10
				  x = 7
				  This is function2
				  x = 5
				  ````
				  在上面的例子中，我们有三个不同作用域的变量：
				  1. 主函数中的局部变量x，其作用域从声明到main函数结束。
				  2. function1函数内的局部变量x，其作用域仅限于function1函数内部，它会在每次调用function1函数时创建并被销毁。
				  3. 块作用域中的局部变量x，其作用域仅限于块内部，即由大括号括起来的范围内。它会在块结束后被销毁。
				  
				  通过理解作用域和生命周期的概念，我们可以更好地控制和管理变量在程序中的可见性和生存时间，以便正确地使用和管理内存资源。
			- ## 常量的类型
			  collapsed:: true
				- 在C语言中，常量可以分为以下几种类型：
				  
				  1. 整型常量：表示整数值，可以是十进制、八进制或十六进制形式。例如`10`、`012`、`0xA`等都是整型常量。
				  2. 浮点型常量：表示实数值，可以是小数形式或科学计数法形式。例如，`3.14`、`1.23e-4`等都是浮点型常量。
				  3. 字符常量：表示单个字符值，用单引号括起来。例如，`'A'`、`'5'`、`'\n'`等都是字符常量。
				  4. 字符串常量：表示多个字符组成的字符串，用双引号括起来。例如，"Hello"、"C Language"等都是字符串常量。
				  5. 枚举常量：表示一组相关的离散值，使用`enum`关键字定义。例如，枚举类型定义`enum Day {SUNDAY, MONDAY, TUESDAY}`中的SUNDAY、MONDAY等就是枚举常量。
				  6. 指针常量：表示一个指针的常量值，用于指向特定的内存地址。例如，`int *const p`中的`p`就是指针常量。
				  7. 宏常量：使用宏定义指令`#define`定义的常量值。例如，`#define MAX_VALUE 100`中的`MAX_VALUE`就是宏常量。
				  
				  这些常量在程序中的值是不可修改的，它们可以用于表达式、赋值、条件判断等各种上下文中。常量的类型定义决定了它们在内存中所占用的空间大小和表示范围。
				  
				  假设有以下的枚举类型定义：
				  
				  ```c
				  enum Season 
				  {
				    SPRING,
				    SUMMER,
				    AUTUMN,
				    WINTER
				  };
				  ```
				  
				  这里`SPRING`、`SUMMER`、`AUTUMN`、`WINTER`是枚举常量。它们表示了季节的四个取值。在程序中，可以使用这些常量来表示不同的季节，比如：
				  
				  ```c
				  enum Season currentSeason = SPRING;
				  ```
				  
				  在这个例子中，`currentSeason`被赋值为`SPRING`，表示当前季
				  
				  假设我们需要定义一个圆的常量，其中包括使用`#define`和`const`两种方式：
				  
				  使用`#define`定义常量：
				  ```c
				  #include <stdio.h>
				  
				  #define PI 3.14159
				  
				  int main() {
				    double radius = 5.0;
				    double circumference = 2 * PI * radius;
				    
				    printf("圆的周长为: %.2f\n", circumference);
				    
				    return 0;
				  }
				  ```
				  
				  使用`const`定义常量：
				  ```c
				  #include <stdio.h>
				  
				  int main() {
				    const double PI = 3.14159;
				    double radius = 5.0;
				    double circumference = 2 * PI * radius;
				    
				    printf("圆的周长为: %.2f\n", circumference);
				    
				    return 0;
				  }
				  ```
				  
				  这两种方式都定义了一个常量`PI`，它表示圆的周长中的π值。无论使用哪种方式，都可以在程序中使用该常量来进行计算。
				  [C 常量 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-constants.html)
			- ## 字符串
			  collapsed:: true
				- C语言中的字符串是由字符组成的字符数组。在C语言中，字符串以null字符（'\0'）结尾，也称为字符串终止字符。C语言没有内置的字符串类型，而是通过使用字符数组来存储和操作字符串。
				  
				  要定义一个字符串，可以声明一个字符数组，并初始化为包含所需的字符。比如：
				  ```c
				  char str[10] = "Hello";
				  ```
				  在这个例子中，我们声明了一个字符数组`str`，大小为10，然后将其初始化为包含字符串`"Hello"`。注意，字符数组的大小至少应该比字符串的长度大1，以留出存储字符串终止字符的位置。
				  
				  字符串可以通过多种方式进行操作。C语言提供了一些内置的库函数，可以用于字符串的处理，如`strlen`、`strcpy`、`strcat`等。
				  
				  举个例子，下面是一个使用`strlen`函数获取字符串长度的例子：
				  ```c
				  #include <stdio.h>
				  #include <string.h>
				  
				  int main() {
				      char str[10] = "Hello";
				      int length = strlen(str);
				      printf("Length of the string: %d\n", length);
				      
				      return 0;
				  }
				  ```
				  输出：
				  ```
				  Length of the string: 5
				  ```
				  
				  这个例子中，我们包含了`<stdio.h>`头文件以使用`printf`函数，和`<string.h>`头文件以使用`strlen`函数。`strlen`函数接受一个字符串作为参数，并返回其长度。
				  
				  当操作字符串时，需要小心避免数组越界和内存溢出等问题。此外，C语言中的字符串是不可变的，即不能直接修改字符串中的某个字符，除非使用数组索引进行修改。如果需要对字符串进行修改，可以使用字符数组提供的函数来实现。
				  
				  总而言之，C语言的字符串是由字符数组构成的，并以null字符结尾。通过使用字符数组和内置的字符串处理函数，我们可以在C语言中进行字符串的操作和处理。
			- ## C语言的ASCII 表
			  collapsed:: true
				- |ASCII值 |字符             |
				  |:--|:--|     
				  |0|NUL (空字符)|
				  |1|SOH (标题开始)|
				  |2|STX (正文开始)|      
				  |3|ETX (正文结束)|
				  |4|EOT (传输结束)|
				  |5|ENQ (请求发送机)|
				  |6|ACK (应答)|
				  |7|BEL (反应器)| 
				  |8|BS (退格)|
				  |9|HT (水平制表符)|
				  |10|LF (换行)|
				  |11|VT (垂直制表符)|
				  |12|FF (换页)|
				  |13|CR (回车)|        
				  |14|SO ( Shackleton符)|
				  |15|SI (启动标志)|
				  |16|DLE (数据链路结尾)|
				  |17|DC1 (设备控制1)|       
				  |18|DC2 (设备控制2)|   
				  |19|DC3 (设备控制3)|   
				  |20|DC4 (设备控制4)|
				  |21|NAK (否认)|    
				  |22|SYN (同步)|
				  |23|ETB (结束传输块)|  
				  |24|CAN (取消)|
				  |25|EM (终止多重传输)|
				  |26|SUB (替换)|    
				  |27|ESC (逃避)|
				  |28|FS (文件分割符)|       
				  |29|GS (组开始)|
				  |30|RS (记录分割符)|
				  |31|US (单元分割符)|
				  | 32       |空格      |
				  | 33       | !    |
				  | 34       | "    |
				  | 35       | #    |
				  | 36       | $    |
				  | 37       | %    |
				  | 38       | &    |
				  | 39       | '    |
				  | 40       | (    |
				  | 41       | )    |
				  | 42       | *    |
				  | 43       | +    |
				  | 44       | ,    |
				  | 45       | -    |
				  | 46       | .    |
				  | 47       | /    |
				  | 48       | 0    |
				  | 49       | 1    |
				  | 50       | 2    |
				  | 51       | 3    |
				  | 52       | 4    |
				  | 53       | 5    |
				  | 54       | 6    |
				  | 55       | 7    |
				  | 56       | 8    |
				  | 57       | 9    |
				  | 58       | :    |
				  | 59       | ;    |
				  | 60       | <    |
				  | 61       | =    |
				  | 62       | >    |
				  | 63       | ?    |
				  | 64       | @    |
				  | 65       | A    |
				  | 66       | B    |
				  | 67       | C    |
				  | 68       | D    |
				  | 69       | E    |
				  | 70       | F    |
				  | 71       | G    |
				  | 72       | H    |
				  | 73       | I    |
				  | 74       | J    |
				  | 75       | K    |
				  | 76       | L    |
				  | 77       | M    |
				  | 78       | N    |
				  | 79       | O    |
				  | 80       | P    |
				  | 81       | Q    |
				  | 82       | R    |
				  | 83       | S    |
				  | 84       | T    |
				  | 85       | U    |
				  | 86       | V    |
				  | 87       | W    |
				  | 88       | X    |
				  | 89       | Y    |
				  | 90       | Z    |
				  | 91       | [    |
				  | 92       | \    |
				  | 93       | ]    |
				  | 94       | ^    |
				  | 95       | _    |
				  | 96       | `    |
				  | 97       | a    |
				  | 98       | b    |
				  | 99       | c    |
				  | 100      | d    |
				  | 101      | e    |
				  | 102      | f    |
				  | 103      | g    |
				  | 104      | h    |
				  | 105      | i    |
				  | 106      | j    |
				  | 107      | k    |
				  | 108      | l    |
				  | 109      | m    |
				  | 110      | n    |
				  | 111      | o    |
				  | 112      | p    |
				  | 113      | q    |
				  | 114      | r    |
				  | 115      | s    |
				  | 116      | t    |
				  | 117      | u    |
				  | 118      | v    |
				  | 119      | w    |
				  | 120      | x    |
				  | 121      | y    |
				  | 122      | z    |
				  | 123      | {    |
				  | 124      | \|   |
				  | 125      | }    |
				  | 126      | ~    |
				  | 127      | DEL  |
				  
				  ```c
				  #include <stdio.h>
				  int main()
				  {
				      char c;
				      printf("输入一个字符: ");
				   
				      // 读取用户输入
				      scanf("%c", &c);  
				      
				      // %d 显示整数
				      // %c 显示对应字符
				      printf("%c 的 ASCII 为 %d", c, c);
				      return 0;
				  }
				  ```
				  [ASCII码一览表，ASCII码对照表 (biancheng.net)](http://c.biancheng.net/c/ascii/)
			- ## C 数组
			  collapsed:: true
				- C语言中的数组是一种存储相同类型元素的数据结构。它可以在内存中连续地存储一组元素，并使用索引来访问每个元素。数组的大小在声明时被指定，并且在整个程序执行过程中保持不变。
				  
				  在C语言中，可以通过以下方式声明和初始化一个数组：
				  
				  ```c
				  <数据类型> <数组名称>[<数组大小>];
				  ```
				  
				  例如，声明一个包含5个整数的数组可以这样写：
				  
				  ```c
				  int numbers[5];
				  ```
				  
				  可以使用索引来访问数组中的每个元素，索引从0开始，依次递增。例如，要访问数组中的第三个元素，可以这样写：
				  
				  ```c
				  numbers[2];
				  ```
				  
				  可以使用循环结构遍历数组中的所有元素。下面是一个使用`for`循环输出数组元素的例子：
				  
				  ```c
				  for (int i = 0; i < 5; i++) {
				      printf("%d ", numbers[i]);
				  }
				  ```
				  
				  C语言中的数组还支持多维数组。多维数组可以理解为数组的数组。例如，可以声明一个二维整数数组如下：
				  
				  ```c
				  int matrix[3][3];
				  ```
				  
				  可以使用两个嵌套的循环来遍历二维数组中的所有元素。例如：
				  
				  ```c
				  for (int i = 0; i < 3; i++) {
				      for (int j = 0; j < 3; j++) {
				          printf("%d ", matrix[i][j]);
				      }
				      printf("\n");
				  }
				  ```
				  
				  值得注意的是，C语言中的数组没有边界检查，因此在访问数组元素时必须小心，确保不会访问超出数组边界的位置，否则可能会导致未定义的行为或错误。
				  [C 数组 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-arrays.html)
			- ## C 指针
			  collapsed:: true
				-
				- C语言中的指针是一个变量，用于存储另一个变量的内存地址。指针变量可以指向任何数据类型，例如整数、字符、数组或其他指针。指针的主要目的是允许程序直接访问内存位置，从而可以有效地操作和管理数据。
				  
				  定义指针变量时需要指定所指向的数据类型，并使用特殊字符"*"来表示该变量是指针。例如，可以使用以下语法来声明一个整数类型的指针变量：
				  ```c
				  int *ptr;
				  ```
				  
				  指针变量可以通过取地址运算符"&"获得其他变量的地址。例如，如果有一个整数变量`num`，可以通过以下方式将其地址赋给指针变量`ptr`：
				  ```c
				  int num = 10;
				  int *ptr = &num;
				  ```
				  
				  要访问指针指向的变量的值，可以使用间接引用运算符"*"。例如，要获取`ptr`指向的整数变量的值，可以使用以下方式：
				  ```c
				  int value = *ptr;
				  ```
				  
				  指针在C语言中非常常见，并且在动态内存分配、数组、函数参数传递等方面发挥重要作用。熟练掌握指针的概念和使用方法是编写高效和灵活的C程序的关键。
				  
				  *实例*
				  ```c
				  #include <stdio.h>
				   
				  int main ()
				  {
				     int  var = 20;   /* 实际变量的声明 */
				     int  *ip;        /* 指针变量的声明 */
				   
				     ip = &var;  /* 在指针变量中存储 var 的地址 */
				   
				     printf("var 变量的地址: %p\n", &var  );
				   
				     /* 在指针变量中存储的地址 */
				     printf("ip 变量存储的地址: %p\n", ip );
				   
				     /* 使用指针访问值 */
				     printf("*ip 变量的值: %d\n", *ip );
				   
				     return 0;
				  }
				  ````
				  *结果*
				  ````
				  var 变量的地址: 0x7ffeeef168d8
				  ip 变量存储的地址: 0x7ffeeef168d8
				  *ip 变量的值: 20
				  ````
				-
			- ## C 结构体
			  collapsed:: true
				- 结构体（structure）是一种自定义的数据类型，用于组合多个不同类型的变量，以创建一个更复杂的数据结构。它允许我们将相关的变量打包在一起，方便地进行处理和管理。
				  
				  下面是一个示例程序，展示了一个包含结构体的程序：
				  
				  ```C
				  #include <stdio.h>
				  
				  // 定义一个学生结构体
				  struct Student 
				  {
				      char name[20];
				      int age;
				      float gpa;
				  };
				  
				  int main() 
				  {
				      // 声明一个学生结构体变量
				      struct Student student1;
				  
				      // 给结构体的成员赋值
				      strcpy(student1.name, "John");
				      student1.age = 18;
				      student1.gpa = 3.7;
				  
				      // 输出结构体的成员值
				      printf("Name: %s\n", student1.name);
				      printf("Age: %d\n", student1.age);
				      printf("GPA: %.2f\n", student1.gpa);
				  
				      return 0;
				  }
				  ```
				  
				  在这个程序中，我们定义了一个名为`Student`的结构体，它有三个成员变量：`name`、`age`和`gpa`。然后在`main`函数中，我们声明了一个名为`student1`的结构体变量，并给它的成员赋值。最后，我们使用`printf`函数输出结构体的成员值。
				  
				  指针在结构体中的作用主要有两个方面：
				  
				  1. **动态内存分配**：通过结构体指针，我们可以在运行时动态地分配内存空间来创建结构体对象。这样可以灵活地管理内存，并避免静态分配的固定大小限制。
				  
				  2. **结构体成员的访问与修改**：通过结构体指针，我们可以直接访问和修改结构体的成员数据，而无需对整个结构体进行复制或传递。这可以提高效率，并减少对内存的消耗。
				  
				  以下是示例程序中的部分代码，展示了指针在结构体中的作用：
				  
				  ```C
				  struct Student 
				  {
				      char name[20];
				      int age;
				      float gpa;
				  };
				  
				  int main() 
				  {
				      struct Student student1;
				      struct Student *ptr_student1 = &student1;
				  
				      // 通过指针访问和修改结构体的成员值
				      strcpy(ptr_student1->name, "John");
				      ptr_student1->age = 18;
				      ptr_student1->gpa = 3.7;
				  
				      // 输出结构体的成员值
				      printf("Name: %s\n", ptr_student1->name);
				      printf("Age: %d\n", ptr_student1->age);
				      printf("GPA: %.2f\n", ptr_student1->gpa);
				  
				      return 0;
				  }
				  ```
				  
				  在这个示例中，我们声明了一个指向`student1`的结构体指针`ptr_student1`，然后使用指针的箭头操作符`->`来访问和修改结构体的成员值。这样，我们可以直接通过指针来操作结构体，更加灵活和高效。
				  [C 结构体 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-structures.html)
				-
		- # 第2章 分支和循环
		  collapsed:: true
			- ## C 分支语句
				- ### 分支语句if else
					- C语言中的分支语句if、if else和if...else if...else是用于在程序执行过程中根据特定条件选择不同的执行路径。
					  
					  **1. if语句**：if语句用于判断一个条件是否成立，如果条件为真，则执行if语句块中的代码，否则跳过if语句块。if语句的基本语法格式如下：
					  
					  ```c
					  if (condition)
					  {
					      // 如果条件为真则执行这里的代码
					  }
					  ```
					  
					  示例：
					  ```c
					  int num = 10;
					  if (num > 0) {
					      printf("Number is positive.");
					  }
					  ```
					  
					  **2. if else语句**：if else语句用于在条件为真时执行某个代码块，而在条件为假时执行另一个代码块。它扩展了if语句的功能，提供了两种不同的执行路径。if else语句的基本语法格式如下：
					  
					  ```c
					  if (condition)
					  {
					      // 如果条件为真则执行这里的代码
					  }
					  else
					  {
					      // 如果条件为假则执行这里的代码
					  }
					  ```
					  
					  示例：
					  ```c
					  int num = 0;
					  if (num > 0) {
					      printf("Number is positive.");
					  } else {
					      printf("Number is non-positive.");
					  }
					  ```
					  
					  **3. if...else if...else语句**：如果需要判断多个条件，并根据不同的条件执行不同的代码块，可以使用if...else if...else语句。这种语句允许我们在多个条件之间进行选择。它的基本语法格式如下：
					  
					  ```c
					  if (condition1)
					  {
					      // 如果条件1为真则执行这里的代码
					  }
					  else if (condition2)
					  {
					      // 如果条件2为真则执行这里的代码
					  }
					  else if (condition3)
					  {
					      // 如果条件3为真则执行这里的代码
					  }
					  ...
					  else
					  {
					      // 如果所有条件都为假，则执行这里的代码
					  }
					  ```
					  
					  示例：
					  ```c
					  int num = 10;
					  if (num > 0) {
					      printf("Number is positive.");
					  } else if (num < 0) {
					      printf("Number is negative.");
					  } else {
					      printf("Number is zero.");
					  }
					  ```
					  
					  这三种分支语句使得我们能够根据不同条件的满足情况选择不同的执行路径，从而实现更丰富的控制流程。
					  [C if 语句 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-if.html)
					  [C if…else 语句 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-if-else.html)
				- ###  嵌套 if 语句
				  collapsed:: true
					- C 语言中，嵌套 if 语句允许在一个 if 语句内包含另一个 if 语句。这样可以根据多个条件来做出更复杂的决策。下面是一个示例：
					  
					  ```c
					  #include <stdio.h>
					  
					  int main() {
					      int num = 15;
					  
					      if (num > 10) {
					          printf("Number is greater than 10.\n");
					  
					          if (num > 20) {
					              printf("Number is also greater than 20.\n");
					          }
					          else {
					              printf("Number is not greater than 20.\n");
					          }
					      }
					      else {
					          printf("Number is not greater than 10.\n");
					      }
					  
					      return 0;
					  }
					  ```
					  
					  在上面的示例中，我们通过嵌套 if 语句进行了条件判断。首先，我们判断变量 `num` 是否大于 10。如果是，打印 "Number is greater than 10."。然后，我们再次使用 if 语句来判断 `num` 是否大于 20。如果是，打印 "Number is also greater than 20."，否则打印 "Number is not greater than 20."。如果 `num` 不大于 10，那么打印 "Number is not greater than 10."。
					  
					  注意，在嵌套 if 语句中，内部的 if 语句会根据外部 if 语句的条件进行判断。因此，当外部 if 语句的条件不满足时，内部的 if 语句将被跳过。这样，我们可以根据多个条件的组合来实现复杂的逻辑判断。
					  [C 嵌套 if 语句 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-nested-if.html)
				- ### 悬空else问题
				  collapsed:: true
					- C语言中的悬空else问题是指当if语句中缺少了与之对应的else语句时，会导致else语句与哪个if语句匹配成为模糊不清的问题。
					  
					  举个例子：
					  
					  ```c
					  int num = 10;
					  
					  if (num > 5)
					      if (num < 15)
					          printf("num 在 5 和 15 之间\n");
					  else
					      printf("num 不大于 5\n");
					  ```
					  
					  在这个例子中，第一个if语句没有对应的else语句，而第二个if语句后面紧跟着一个else语句。根据C语言的语法规定，else语句会与最近的未匹配的if语句相匹配。因此，上述代码的实际执行结果可能会与预期不符。^^就近原则^^
					  
					  预期的结果是，如果num大于5且小于15，则输出"num 在 5 和 15 之间"；否则，输出"num 不大于 5"。然而，由于第一个if语句没有else语句，导致第二个if语句的else语句作为当前最近的未匹配的if语句的else语句，因此在该例子中，无论num的值是多少，最终都会输出"num 不大于 5"。
					  
					  为了避免悬空else问题，我们可以使用大括号（花括号）来明确指定if和else的范围，以确保正确的语句块与相应的条件进行匹配。修正后的代码如下：
					  
					  ```c
					  int num = 10;
					  
					  if (num > 5) {
					      if (num < 15) {
					          printf("num 在 5 和 15 之间\n");
					      }
					  } else {
					      printf("num 不大于 5\n");
					  }
					  ```
					  
					  这样，无论num的值是多少，输出的结果都会符合预期。
				- ### 分支语句 switch
				  collapsed:: true
					- 在C语言中，我们可以使用`switch`语句来进行分支判断。它允许我们根据一个变量的不同取值来执行不同的代码块。
					  
					  `switch`语句的基本语法如下：
					  ```c
					  switch (expression) {
					    case value1:
					      // 当表达式的值等于value1时执行的代码块
					      break;
					    case value2:
					      // 当表达式的值等于value2时执行的代码块
					      break;
					    ...
					    default:
					      // 当表达式的值与上述的case都不匹配时执行的代码块
					      break;
					  }
					  ```
					  
					  `expression`是一个表达式，其值将与`case`后的取值进行匹配。如果匹配成功，则执行相应的代码块。`break`语句用于跳出`switch`语句，防止执行其他`case`分支。
					  
					  `default`关键字用于处理`expression`值与所有`case`值都不匹配的情况。如果没有匹配的`case`，则将执行`default`后面的代码块。
					  
					  需要注意的是，`switch`语句中的`expression`必须是整数类型或字符类型，而`case`后的值必须是常量表达式。
					  
					  以下是一个简单的示例：
					  ```c
					  int num = 2;
					  
					  switch (num) {
					    case 1:
					      printf("Number is 1");
					      break;
					    case 2:
					      printf("Number is 2");
					      break;
					    case 3:
					      printf("Number is 3");
					      break;
					    default:
					      printf("Number is not 1, 2, or 3");
					      break;
					  }
					  ```
					  
					  在上述示例中，根据变量`num`的值，将选择执行相应的代码块，并输出相应的信息。
					  [C switch 语句 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-switch.html)
				- ### 嵌套 switch 语句
				  collapsed:: true
					- C 语言中可以使用嵌套的 switch 语句来处理多个不同的条件。嵌套 switch 语句的语法与普通的 switch 语句类似，只是在 case 标签下面再嵌套了一个新的 switch 语句。
					  
					  以下是嵌套 switch 语句的一般语法：
					  
					  ```c
					  switch (expression1) {
					      case constant1:
					          // 嵌套 switch 语句
					          switch (expression2) {
					              case constant2:
					                  // 执行相应的操作
					                  break;
					              case constant3:
					                  // 执行相应的操作
					                  break;
					              default:
					                  // 执行默认操作
					                  break;
					          }
					          break;
					      case constant4:
					          // 执行相应的操作
					          break;
					      default:
					          // 执行默认操作
					          break;
					  }
					  ```
					  
					  嵌套 switch 语句中的 expression1 和 expression2 是需要进行判断的表达式，constant1、constant2 等是常量值，用于与表达式进行比较。根据不同的表达式和常量值，程序会根据条件执行相应的操作代码块。
					  
					  嵌套 switch 语句的使用可以在处理复杂的多重条件时提供更灵活的控制结构，使代码更加清晰和易于维护。但需要注意的是，嵌套 switch 语句的层级不宜过多，以免降低代码的可读性。
					  [C 嵌套 switch 语句 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-nested-switch.html)
				- [C 判断 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-decision.html)
			- ## C循环语句
			  collapsed:: true
				- ### C while循环
				  collapsed:: true
					- C语言中的while循环用于重复执行一段代码，只要给定的条件为真。它的语法如下：
					      
					  ```
					  while (condition)
					  {
					      // 代码块
					  }
					  ```
					  
					  在这个循环中，首先计算condition表达式的布尔值。如果条件为真，那么代码块中的语句会被执行，然后再次检查条件的值。如果条件仍然为真，循环会继续执行，直到条件变为假，此时循环停止，代码继续执行。
					  
					  在循环体内部，可以执行任何语句或操作。循环体内通常会对循环控制变量或其他相关变量进行操作，以便在每次循环迭代时更新条件。
					  
					  注意，在使用while循环时，一定要确保循环条件在某个点上为假，否则会造成无限循环，导致程序陷入永久的循环中。为了避免这种情况发生，需要在循环体内部更新循环条件，或者使用break语句在某个特定条件下跳出循环。
					  
					  以下是一个简单的示例，用于演示while循环的用法：
					  
					  ```c
					  #include <stdio.h>
					  
					  int main()
					  {
					      int i = 1;
					      
					      while (i <= 5)
					      {
					          printf("%d\n", i);
					          i++;
					      }
					      
					      return 0;
					  }
					  ```
					  
					  这个示例会输出从1到5的数字。循环条件i <= 5在每次循环迭代时都会被检查，直到i的值为6时，条件变为假，循环结束。在每次循环迭代时，我们会打印出当前的i值，并使用i++语句递增i的值。
					  [C while 循环 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-while-loop.html)
				- ### getchar语句
				  collapsed:: true
					- `getchar`是一个C语言函数，用于从标准输入流中获取一个字符。它的函数原型为：
					  
					  ```c
					  int getchar(void);
					  ```
					  
					  该函数会等待用户输入一个字符，并返回该字符的ASCII码值。如果发生错误或到达文件结束符，函数将返回`EOF`。
					  
					  以下是一个示例程序，展示了如何使用`getchar`函数从标准输入读取字符并打印出来：
					  
					  ```c
					  #include <stdio.h>
					  
					  int main() {
					      int ch;
					      
					      // 使用循环读取多个字符
					      while ((ch = getchar()) != EOF) {
					          printf("ASCII码值：%d，字符：%c\n", ch, ch);
					      }
					      
					      return 0;
					  }
					  ```
					  
					  在运行以上程序时，可以逐个输入字符，并查看每个字符的ASCII码值和字符本身。当输入文件结束符（通常为`Ctrl + Z`或`Ctrl + D`）时，循环将终止。注意，`getchar`函数每次只能读取一个字符，如果需要读取多个字符，可以在循环中多次调用该函数。
					  https://blog.csdn.net/Huang_WeiHong/article/details/109455150
				- ### C for 循环
				  collapsed:: true
					- 在C语言中，循环结构提供了一种重复执行代码块的方式。其中最常用的是for循环。
					  
					  for循环由三个部分组成：初始化、循环条件和更新操作。它的基本语法如下：
					  
					  ```
					  for (初始化; 循环条件; 更新操作) 
					  {
					      // 循环体代码
					  }
					  ```
					  
					  在初始化部分，我们可以声明并初始化一个计数器变量，该变量用于跟踪循环的执行次数。循环条件是一个布尔表达式，只有在条件为真时循环才会继续执行。更新操作负责对计数器变量进行递增或递减。
					  
					  在每次循环迭代中，先检查循环条件是否为真。如果为真，则执行循环体中的代码，然后执行更新操作。之后再次检查循环条件。如果循环条件为假，则循环终止。
					  
					  例如，如果我们想要打印从0到9的数字，可以使用以下for循环：
					  
					  ```c
					  for (int i = 0; i < 10; i++) 
					  {
					      printf("%d ", i);
					  }
					  ```
					  
					  这将输出：0 1 2 3 4 5 6 7 8 9。
					  
					  在循环体内，我们可以执行任意代码，包括条件语句、函数调用等。我们也可以使用break语句提前终止循环，或者使用continue语句跳过当前迭代。
					  [C for 循环 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-for-loop.html)
				- ### C do while 循环
				  collapsed:: true
					- C语言中，do-while循环是一种后测试循环结构，也被称为前条件循环。它的语法形式为：
					  
					  ```c
					  do 
					  {
					      // 循环体语句
					  } while (条件);
					  ```
					  
					  do-while循环首先执行循环体中的语句，然后再检查条件。如果条件为真，则继续执行循环体，否则跳出循环。不论条件是否为真，循环体中的语句至少会执行一次。
					  
					  do-while循环的特点是先执行循环体再判断条件，因此无论条件是否满足，循环体中的代码至少会被执行一次。这与其他循环结构（如for和while循环）不同，其他循环结构首先判断条件，如果条件不满足，则不会执行循环体。
					  
					  do-while循环适合处理至少需要执行一次的情况，例如用户输入的确认信息，菜单选项，以及其他需要执行一次的任务。需要注意的是，在循环体内部要保证能改变条件，否则可能导致无限循环。
					  [C do…while 循环 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-do-while-loop.html)
				- [C 循环 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-loops.html)
		- # 第3章 函数
		  collapsed:: true
			- ## C 函数
			  collapsed:: true
				- C语言是一种广泛应用于系统编程和嵌入式开发的程序设计语言。在C语言中，函数是用来封装可重用代码块的主要方式之一。函数在程序中起着模块化和代码复用的作用，帮助程序员组织代码并使其更易于理解和维护。
				  
				  C函数具有以下特点：
				  
				  1. 函数声明：在使用函数之前，需要在代码中先声明函数的原型，以便编译器知道如何调用该函数。函数声明通常包括函数名、参数列表和返回值类型。
				  
				  2. 函数定义：函数定义提供了函数体的具体实现。它通常包含在程序的某个地方，用于定义函数的行为。函数定义由函数头和函数体组成。
				  
				  3. 参数传递：C语言支持通过值传递和指针传递两种方式来向函数传递参数。通过值传递时，函数操作的是参数的副本；通过指针传递时，函数可以直接操作参数的内容。
				  
				  4. 返回值：函数可以有返回值，用于将计算结果返回给调用者。返回值的类型在函数声明和定义时已经指定。
				  
				  5. 局部变量：函数还可以声明局部变量，这些变量仅在函数内部可见，且其生命周期与函数的执行周期相同。局部变量对于函数的封装性和数据隔离性非常重要。
				  
				  6. 递归：C语言支持函数的递归调用，即函数可以调用自身。递归在处理递归定义问题或具有相似结构的问题时非常有用。
				  
				  7. 函数库：C语言提供了许多标准的函数库，例如数学函数库、字符串函数库等。这些函数库提供了各种常用功能的封装，可以直接在程序中调用。
				  
				  使用C函数能够使程序模块化并具备更好的可重用性，提高代码的可读性和维护性。因此，了解和熟练使用C函数是编写高效C程序的重要基础。
			- ## C 函数的调用
			  collapsed:: true
				- 在C语言中，函数调用可以采用^^传值调用（pass by value）^^或^^传址调用（pass by reference）^^的方式。这两种调用方式有着不同的特点和用途。
				  
				  **传值调用**是指函数调用时，将实参的值复制给对应的形参。在函数内部，对形参的任何修改都不会影响到实参的值。传值调用适用于不需要修改实参值的情况，它简单、直观，并且不会产生副作用。
				  **传址调用**是指函数调用时，将实参的地址传递给对应的形参。通过使用指针，函数可以直接操作实参的值。在函数内部修改形参的值会影响到实参的值。传址调用适用于需要修改实参值或需要返回多个值的情况。
				  
				  下面是一个示例代码，演示了传值调用和传址调用的区别：
				  
				  ```c
				  #include <stdio.h>
				  
				  void passByValue(int value) {
				      value = 10;
				  }
				  
				  void passByReference(int* value) {
				      *value = 10;
				  }
				  
				  int main() {
				      int num1 = 5;
				      int num2 = 5;
				  
				      passByValue(num1);
				      passByReference(&num2);
				  
				      printf("num1: %d\n", num1); // 输出：num1: 5
				      printf("num2: %d\n", num2); // 输出：num2: 10
				  
				      return 0;
				  }
				  ```
				  
				  在上面的代码中，`passByValue`函数使用传值调用，将`num1`的值复制给了`value`形参，并在函数内部修改了`value`的值为10。但是，函数结束后，`num1`的值仍然是5，没有被修改。
				  
				  `passByReference`函数使用传址调用，通过传递`num2`的地址给`value`形参，函数内部通过解引用指针修改了`num2`的值为10。函数结束后，`num2`的值被成功修改为10。
				  
				  在实际编程中，可以根据需要选择传值调用或传址调用来传递函数参数，以实现不同的功能和效果。
			- ## 二分查找
			  collapsed:: true
				- 下面是使用C语言实现的二分查找算法的示例代码：
				  ```c
				  #include <stdio.h>
				  
				  int binarySearch(int arr[], int low, int high, int target) {
				      while (low <= high) {
				          int mid = low + (high - low) / 2;
				  
				          if (arr[mid] == target) {
				              return mid;  // 找到目标元素，返回索引
				          } else if (arr[mid] < target) {
				              low = mid + 1;  // 目标元素在右半部分，继续在右半部分查找
				          } else {
				              high = mid - 1;  // 目标元素在左半部分，继续在左半部分查找
				          }
				      }
				  
				      return -1;  // 目标元素不存在，返回-1
				  }
				  
				  int main() {
				      int arr[] = {2, 5, 7, 12, 16, 23, 34, 45, 56, 67};
				      int n = sizeof(arr) / sizeof(arr[0]);
				      int target = 23;
				      
				      int result = binarySearch(arr, 0, n - 1, target);
				  
				      if (result == -1) {
				          printf("目标元素 %d 不存在\n", target);
				      } else {
				          printf("目标元素 %d 在索引 %d 处\n", target, result);
				      }
				  
				      return 0;
				  }
				  ````
				  该示例代码演示了如何使用二分查找算法在已排序的整数数组中查找目标元素。在binarySearch()函数中，通过维护一个搜索范围的上界和下界，以及计算中间索引来实现二分查找。如果找到目标元素，返回其索引；如果目标元素不存在，返回-1。
				  在main()函数中，我们创建一个示例数组arr，并定义目标元素target为23。然后调用binarySearch()函数进行查找，并根据返回结果输出相应的信息。
				  输出示例：
				  ````
				  目标元素 23 在索引 5 处
				  ````
				  请注意，二分查找算法要求目标数组是有序的。如果数组无序，需要先对数组进行排序，然后再使用二分查找算法。
			- ## 函数的嵌套调用和链式访问
			  collapsed:: true
				- ### C 函数嵌套调用
				  collapsed:: true
					- 函数嵌套调用是指在一个函数的定义或执行过程中，调用了另一个函数。这是一种常见的编程技术，能够提高代码的模块化和可读性。在 C 语言中，函数的嵌套调用非常简单。以下是一些示例：
					  
					  ```c
					  #include <stdio.h>
					  
					  // 声明函数 addNumbers
					  int addNumbers(int a, int b) {
					      return a + b;
					  }
					  
					  // 声明函数 multiplyNumbers
					  int multiplyNumbers(int a, int b) {
					      return a * b;
					  }
					  
					  // 声明函数 divideNumbers
					  int divideNumbers(int a, int b) {
					      return a / b;
					  }
					  
					  int main() {
					      int x = 5;
					      int y = 3;
					  
					      int sum = addNumbers(x, y);
					      int product = multiplyNumbers(sum, y);
					      int result = divideNumbers(product, x);
					  
					      printf("Result: %d\n", result);
					  
					      return 0;
					  }
					  ```
					  
					  在上面的示例中，`main()` 函数调用了三个其他函数 `addNumbers()`, `multiplyNumbers()`, `divideNumbers()`。`addNumbers()` 函数接受两个参数并返回它们的和，`multiplyNumbers()` 函数接受两个参数并返回它们的乘积，`divideNumbers()` 函数接受两个参数并返回它们的商。`main()` 函数通过嵌套调用这些函数来计算并输出最终结果。这样的函数嵌套调用可以帮助我们将复杂的问题分解成更小的模块，并提高程序的可读性和维护性。
				- ### C 函数链式访问
				  collapsed:: true
					- 函数链式访问是一种在 C 语言中使用连续调用多个函数的方法，以实现流畅的编码风格。在实际应用中，函数链式访问通常用于对同一个对象（或数据结构）进行一系列操作。
					  
					  要实现函数链式访问，可以使用函数返回值来传递对象的引用，在调用一个函数后直接调用下一个函数。这样可以将多个函数的调用串联起来，减少中间变量的使用，提高代码的可读性。
					  
					  下面是一个简单的示例，演示了如何在 C 语言中实现函数链式访问：
					  
					  ```c
					  #include <stdio.h>
					  
					  struct Person {
					      char name[50];
					      int age;
					  };
					  
					  struct Person* createPerson(char name[], int age) {
					      struct Person* person = malloc(sizeof(struct Person));
					      strcpy(person->name, name);
					      person->age = age;
					      return person;
					  }
					  
					  struct Person* setName(struct Person* person, char name[]) {
					      strcpy(person->name, name);
					      return person;
					  }
					  
					  struct Person* setAge(struct Person* person, int age) {
					      person->age = age;
					      return person;
					  }
					  
					  void printPerson(struct Person* person) {
					      printf("Name: %s, Age: %d\n", person->name, person->age);
					  }
					  
					  int main() {
					      struct Person* john = createPerson("John", 25)->setAge(30)->setName("John Doe")->printPerson();
					      return 0;
					  }
					  ```
					  
					  在上面的示例中，定义了一个 `Person` 结构体，以及用于创建、设置名称、设置年龄和打印信息的函数。在 `main` 函数中，通过使用函数链式访问的方式，创建了一个 `Person` 对象并依次设置年龄和名称，最后打印信息。
					  
					  函数链式访问可以提高代码的可读性和简洁性，但也需要注意在设计函数接口时需要确保连续调用的正确性。此外，对于指针对象，需要谨慎处理空指针的情况，以避免潜在的错误。
				-
			- ## C 函数的声明和定义
			  collapsed:: true
				- ### C 函数的声明
				  collapsed:: true
					- C语言函数的声明是指在使用函数之前提供函数的名称、参数列表及返回类型的信息，以告知编译器这个函数的存在以及如何使用它。^^函数的声明通常放在头文件中，以便在不同的源文件中都可以使用。^^
					  
					  函数声明的一般形式为：
					  ```
					  返回类型 函数名(参数列表);
					  ```
					  其中，返回类型指定函数的返回值类型，函数名是函数的标识符，参数列表是函数的输入参数类型和变量名的列表。
					  
					  例如，声明一个名为sum的函数，它接受两个整型参数并返回一个整型结果，可以这样声明：
					  ```
					  int sum(int num1, int num2);
					  ```
					  
					  需要注意的是，函数的声明与函数的定义是不同的。函数的定义包括了函数的实现代码，而函数的声明只提供了函数的接口信息，不包含实际的代码实现。^^函数的定义通常放在源文件中，而函数的声明可以放在头文件中供多个源文件使用。^^
				- ### C 函数的定义
				  collapsed:: true
					- C 函数的定义是一种编程概念，用于将一段代码封装成可重复使用的模块。函数以关键字 "void"（如果没有返回类型的话）开始，然后是函数的返回类型（如果有的话），接着是函数的名称，接下来是一对括号，括号中包含函数的参数列表，最后是函数体。函数体是一组语句，用大括号括起来。例如，下面是一个简单的 C 函数的定义示例：
					  
					  ```c
					  int sum(int a, int b) {
					      int result = a + b;
					      return result;
					  }
					  ```
					  
					  在这个例子中，函数名称是 "sum"，它有两个参数 "a" 和 "b"，返回类型是 "int"。函数体中的代码计算了参数的和，并将结果存储在 "result" 变量中，最后使用 "return" 语句将结果返回。这样，在其他地方调用该函数时，可以得到计算的结果。
			- ## C 函数递归
				- ### 什么是函数递归
				  collapsed:: true
					- C函数递归是指在C语言中定义一个函数，在函数体内部调用自身的过程。递归函数在解决某些问题时非常有用，特别是那些可以被拆分为更小的相同问题的情况。在递归过程中，函数会重复调用自身，每次调用时问题规模会减小，直到达到某个基本情况，递归才会停止。
					  
					  递归函数的基本思想是将大问题分解为子问题，并通过不断调用自身来解决子问题。递归函数必须具备两个重要的元素：基本情况和递归调用。基本情况是递归终止的条件，它表示问题已经到了最小规模，不需要再继续拆分。递归调用则是指在函数中调用自身来解决子问题。
					  
					  需要注意的是，在编写递归函数时，必须保证存在一个明确的终止条件，以避免无限递归的问题发生。此外，递归函数可能会占用较多的系统栈空间，因此在设计递归算法时需要注意栈溢出的风险。
					  
					  递归函数的应用非常广泛，例如在数据结构中的树、图的遍历算法、数学中的阶乘和斐波那契数列等等，都可以通过递归函数来实现。
					  函数递归是指函数在其定义中调用自身的过程。在递归过程中，函数将自身的问题分解为更小的子问题，并通过递归调用解决这些子问题，最终得到整个问题的解。
					  递归函数通常包含两个部分：
					  1. **递归基（Base Case）**：递归基是递归函数的结束条件。当满足递归基的条件时，函数不再调用自身，而是返回一个特定的值或执行其他操作，从而结束递归过程。
					  2. **递归步骤（Recursive Step）**：递归步骤是递归函数中执行的递归调用部分。在递归步骤中，函数将原始问题分解为更小的子问题，并通过调用自身来解决这些子问题。
					  递归函数可以用于解决那些可以分解为相同问题的子问题的问题。递归的关键在于将大问题划分为更小的同类子问题，直到达到递归基的条件。
					  以下是一个计算阶乘的递归函数的示例（使用C语言）：
					  ```c
					  #include <stdio.h>
					  
					  int fibonacci(int n); //函数声明
					  
					  int main() {
					      int n = 6;
					      int result = fibonacci(n);
					      printf("The %dth Fibonacci number is: %d\n", n, result);
					      return 0;
					  }
					  
					  int fibonacci(int n) {
					      // 递归基
					      if (n == 0) {
					          return 0;
					      }
					      else if (n == 1) {
					          return 1;
					      }
					      // 递归步骤
					      else {
					          return fibonacci(n - 1) + fibonacci(n - 2);
					      }
					  }
					  ```
					  在这个示例中，`factorial()`函数是一个递归函数，用于计算给定数的阶乘。当`n`等于0时，函数返回1作为递归基；否则，它通过调用自身来计算`(n-1)`的阶乘，并将结果与`n`相乘，得到整个问题的解。
					  输出示例：
					  ```
					  The 6th Fibonacci number is: 8
					  ```
					  需要注意的是，递归函数需要在适当的时候终止递归过程，否则可能会导致无限递归和堆栈溢出等问题。确保设置递归基条件，以确保递归函数能够正常结束。
				- ### 必要条件
				  collapsed:: true
					- 在C语言中，函数递归的必要条件包括以下几点：
					  1. **递归基（Base Case）**：递归函数必须定义一个或多个递归基（基本情况），这些基本情况在递归过程中终止递归的执行。递归基是递归函数中的停止条件，确保递归过程能够结束，避免无限递归。
					  2. **递归步骤（Recursive Step）**：递归函数必须定义一个或多个递归步骤，即在函数内部调用自身来解决规模更小的同类子问题。递归步骤通过将原始问题转化为更小规模的子问题，逐步向递归基逼近，实现问题的分解和解决。
					  3. **问题规模缩小**：递归函数必须通过每次递归调用来缩小问题的规模，使得问题在每一次递归调用中变得更小。否则，递归过程将无法结束，导致无限递归。
					  4. **向递归基靠近**：递归函数必须确保通过递归步骤向递归基靠近。也就是说，每次递归调用都应该使问题的规模更接近递归基的情况，直到达到递归基从而结束递归过程。
					  当这些条件都满足时，函数才能被称为递归函数。递归函数通过递归基和递归步骤的结合，实现了将大问题分解为小问题并逐步解决的过程。
					  需要注意的是，递归虽然强大，但使用不当可能会导致性能问题或栈溢出等错误，因此在设计递归函数时需要谨慎。确保递归函数满足上述必要条件，同时合理控制递归的深度和规模，以确保程序的正确性和性能。
			-
		- # 第4章 数组
		  collapsed:: true
			- ## 一维数组
			  collapsed:: true
				- ### C 一维数组的创建与初始化
				  collapsed:: true
					- 要创建和初始化C中的一维数组，可以使用以下语法：
					  
					  ```c
					  <数据类型> <数组名称>[<数组大小>] = {<元素1>, <元素2>, ..., <元素N>};
					  ```
					  
					  这是一个简便的方法，可以在创建数组的同时将其元素初始化为指定的值。以下是一个示例：
					  
					  ```c
					  int numbers[5] = {1, 2, 3, 4, 5};
					  ```
					  
					  在这个示例中，我们声明了一个名为`numbers`的整数数组，包含5个元素。数组的第一个元素是1，第二个元素是2，依此类推。
					  
					  如果不提供初始值，数组的元素将自动初始化为零。
					  
					  ```c
					  int numbers[3] = {0}; // 所有元素都初始化为0
					  ```
					  
					  还可以使用循环结构来初始化数组的元素：
					  
					  ```c
					  int numbers[5];
					  for (int i = 0; i < 5; i++) {
					      numbers[i] = i + 1;
					  }
					  ```
					  
					  在这个示例中，我们首先声明了一个名为`numbers`的整数数组，然后使用循环将其元素分别初始化为1到5的值。
					  
					  获取一维数组的长度
					  ```c
					  int length = sizeof(numbers) / sizeof(numbers[0]);  // 计算一维数组的长度
					  ```
					  无论使用哪种方法，创建和初始化一维数组的步骤都是类似的，具体取决于你的需求和代码结构。
				- ### C 一维数组的使用
				  collapsed:: true
					- C语言中，一维数组是一种存储相同类型元素的连续内存块的数据结构。它是最简单的数组形式，使用数组可以方便地存储和操作一组数据。
					  
					  在C中声明和使用一维数组的一般步骤如下：
					  
					  1. 声明数组：指定数组的类型和名称，并指定数组的大小，即包含的元素个数。
					     ```
					     int myArray[5];  // 声明一个包含5个整数类型元素的一维数组
					     ```
					  
					  2. 初始化数组：在声明数组的同时，也可以为数组赋初值。
					     ```
					     int myArray[5] = {1, 2, 3, 4, 5};  // 声明并初始化一维数组
					     ```
					  
					  3. 访问数组元素：通过指定数组名称和索引来访问数组中的元素，数组索引从0开始。
					     ```
					     int value = myArray[2];  // 获取索引为2的元素的值（即第3个元素）
					     ```
					  
					  4. 修改数组元素：通过指定数组名称和索引，可以修改数组中的元素。
					     ```
					     myArray[2] = 10;  // 修改索引为2的元素的值为10
					     ```
					  
					  5. 遍历数组：可以使用循环来遍历数组中的所有元素，以执行特定的操作。
					     ```
					     for (int i = 0; i < 5; i++) {
					         printf("%d ", myArray[i]);  // 打印数组中的元素
					     }
					     ```
					  
					  一维数组在C语言中被广泛应用，可以用于存储和处理大量的数据。通过对数组的操作，可以实现各种算法和数据结构，如排序、查找等。
				- [C 数组 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-arrays.html)
			- ## 二维数组
			  collapsed:: true
				- ### C 二维数组的创建和初始化
				  collapsed:: true
					- 在 C 语言中，可以通过二维数组来表示一个矩阵或者表格。创建和初始化二维数组的方法如下：
					  
					  1. 静态创建和初始化：
					  ```c
					  int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
					  ```
					  这里创建了一个 3x3 的矩阵，并且对矩阵中的每个元素进行了初始化。
					  
					  2. 动态创建和初始化：
					  ```c
					  int rows = 3;
					  int cols = 3;
					  int **matrix = (int **)malloc(rows * sizeof(int *));
					  for (int i = 0; i < rows; i++) {
					      matrix[i] = (int *)malloc(cols * sizeof(int));
					  }
					  ```
					  这里使用了指针来创建一个动态的二维数组，并且对数组中的每个元素进行了初始化。需要注意的是，动态创建的二维数组需要手动释放内存。
					  
					  3. 逐行初始化：
					  ```c
					  int matrix[3][3];
					  for (int i = 0; i < 3; i++) {
					      for (int j = 0; j < 3; j++) {
					          matrix[i][j] = i + j;
					      }
					  }
					  ```
					  这里使用两个嵌套的循环逐行对二维数组进行初始化。
					  
					  无论使用哪种方法，都可以通过下标访问和修改二维数组中的元素。比如，`matrix[1][2]` 表示矩阵中第 2 行
				- ### C 二维数组的使用
				  collapsed:: true
					- C语言中，二维数组是一个由多个一维数组组成的数据结构。可以用于存储和处理二维数据，例如矩阵、表格等。
					  
					  二维数组的声明和初始化可以通过以下方式进行：
					  
					  ```c
					  datatype arrayName[rowSize][columnSize] = { {value1, value2, value3}, {value4, value5, value6}, ... };
					  ```
					  
					  其中，`datatype`表示要存储在数组中的数据类型，`arrayName`是数组的名称，`rowSize`和`columnSize`分别表示二维数组的行数和列数。花括号内的值是可选的，用于初始化数组。
					  
					  下面是一个具体的示例，演示了如何声明、初始化和访问二维数组中的元素：
					  
					  ```c
					  #include <stdio.h>
					  
					  int main() {
					      int matrix[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
					  
					      // 访问二维数组中的元素
					      printf("%d\n", matrix[0][0]); // 输出：1
					      printf("%d\n", matrix[1][2]); // 输出：6
					  
					      return 0;
					  }
					  ```
					  
					  以上代码中，`matrix`是一个3x3的整数二维数组，包含了1到9的数字。通过使用`matrix[rowIndex][columnIndex]`的形式，可以访问特定位置的元素。
					  
					  需要注意的是，C语言中的二维数组是按行主序存储的，也就是说，相邻行的元素在内存中是连续存储的。因此，可以通过循环嵌套遍历整个二维数组的元素。
				- ### 二维数组在数组中存储
				  collapsed:: true
					- 在C语言中，二维数组是以行为主的连续存储方式。它在内存中被存储为一块连续的存储空间，按照行主序的顺序存储元素。
					  具体来说，二维数组是由一系列一维数组构成的。每个一维数组表示二维数组的一行，多个一维数组按顺序排列，构成整个二维数组。
					  考虑一个具体的示例，假设我们有一个3行4列的整数二维数组`matrix`，它的内存存储如下所示：
					  ```
					  matrix[0][0]  matrix[0][1]  matrix[0][2]  matrix[0][3]  matrix[1][0]  matrix[1][1]  matrix[1][2]  matrix[1][3]  matrix[2][0]  matrix[2][1]  matrix[2][2]  matrix[2][3]
					  ```
					  在内存中，元素按照行优先的顺序存储，即先存储第0行的元素，然后是第1行的元素，最后是第2行的元素。每一行的元素按照列顺序存储。
					  可以使用指针和循环来访问和操作二维数组的元素。下面是一个示例程序，演示如何声明、初始化和访问二维数组：
					  ```c
					  #include <stdio.h>
					  int main() {
					    int matrix[3][4] = {
					        {1, 2, 3, 4},
					        {5, 6, 7, 8},
					        {9, 10, 11, 12}
					    };
					  // 访问二维数组的元素
					    for (int i = 0; i < 3; i++) {
					        for (int j = 0; j < 4; j++) {
					            printf("matrix[%d][%d]: %d\n", i, j, matrix[i][j]);
					        }
					    }
					  return 0;
					  }
					  ```
					  在上面的示例中，我们声明了一个3行4列的整数二维数组`matrix`。然后，使用嵌套的`for`循环遍历二维数组，并打印每个元素的值和对应的索引。
					  需要注意的是，二维数组的行和列都从0开始计数，所以遍历时使用的索引范围是0到行数减一和列数减一。
				- ### 数组作为函数参数
				  collapsed:: true
					- 在C中，可以将数组作为函数参数传递。通过将数组作为参数传递给函数，可以在函数内部访问和修改数组的元素。有两种常用的方法来传递数组作为函数参数：
					  
					  1. 传递指针：可以将数组的地址（即指针）作为函数参数传递。函数声明中指定参数为指针类型，并在函数内部通过指针访问和修改数组的元素。以下是一个示例：
					  
					  ```c
					  void function_name(data_type array_name[], int size) {
					      // 函数代码，可以访问和修改数组元素
					  }
					  
					  int main() {
					      data_type my_array[size];
					      // 对数组赋值
					  
					      function_name(my_array, size);
					      // 调用函数，并传递数组作为参数
					  
					      // 之后可以在main函数中使用修改后的数组
					      return 0;
					  }
					  ```
					  
					  2. 传递数组的大小：可以将数组的大小作为函数参数传递。函数声明中指定参数为数组类型和数组大小，并在函数内部使用该大小进行操作。以下是一个示例：
					  
					  ```c
					  void function_name(data_type array_name[size], int size) {
					      // 函数代码，可以访问和修改数组元素
					  }
					  
					  int main() {
					      data_type my_array[size];
					      // 对数组赋值
					  
					      function_name(my_array, size);
					      // 调用函数，并传递数组和大小作为参数
					  
					      // 之后可以在main函数中使用修改后的数组
					      return 0;
					  }
					  ```
					  
					  无论使用哪种方法，都可以在函数内部访问和修改传递给函数的数组。这样可以在函数中对数组进行各种操作，而不会对其他部分的数组产生影响。
				- [C 多维数组 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-multi-dimensional-arrays.html)
		- # 第5 章 操作符
		  collapsed:: true
			- ## 算术运算符
			  collapsed:: true
				- | 运算符 | 描述 | 实例 |
				  |---|---|---|
				  | + | 加法运算符,相加操作数 | a + b 输出a和b的和 |
				  | - | 减法运算符,相减操作数 | a - b 输出a减去b的值 |
				  | * | 乘法运算符,相乘操作数 | a * b 输出a和b相乘之积 |
				  | / | 除法运算符,相除操作数 | a / b 输出a除以b的商 |
				  | % | 取模运算符,取余数 | a % b 输出a除以b的余数 |
				  | ++ | 自增运算符,使操作数值增1 | a++ 将a增加1 |
				  | -- | 自减运算符,使操作数值减1 | a-- 将a减少1 |
				  *实例*  
				  ```c
				  #include <stdio.h>
				   
				  int main()
				  {
				     int a = 21;
				     int b = 10;
				     int c ;
				   
				     c = a + b;
				     printf("Line 1 - c 的值是 %d\n", c );
				     c = a - b;
				     printf("Line 2 - c 的值是 %d\n", c );
				     c = a * b;
				     printf("Line 3 - c 的值是 %d\n", c );
				     c = a / b;
				     printf("Line 4 - c 的值是 %d\n", c );
				     c = a % b;
				     printf("Line 5 - c 的值是 %d\n", c );
				     c = a++;  // 赋值后再加 1 ，c 为 21，a 为 22
				     printf("Line 6 - c 的值是 %d\n", c );
				     c = a--;  // 赋值后再减 1 ，c 为 22 ，a 为 21
				     printf("Line 7 - c 的值是 %d\n", c );
				   
				  }
				  ```
				- %运算符,也称取模运算符,它用于计算两个操作数的除法的余数。
				  使用%运算符时,有以下几点要求:  
				  1. 两个操作数都必须是整数类型,不能是小数或者浮点数。如sizeof、int等整型都可以,double、float不可以。
				  2. 除数不能为0。因为整数除以0是没有意义的,会导致运行时错误。
				  3. 结果也是整数类型。无论原操作数是什么类型,结果都为非负整数。
				  4. 它采用整除法则,也就是ignoring小数部分,只保留整数部分。
				- #### ^^++和--前置和后置的区别^^
				  ```c
				  #include <stdio.h>
				   
				  int main()
				  {
				     int c;
				     int a = 10;
				     c = a++; 
				     printf("先赋值后运算：\n");
				     printf("Line 1 - c 的值是 %d\n", c );
				     printf("Line 2 - a 的值是 %d\n", a );
				     a = 10;
				     c = a--; 
				     printf("Line 3 - c 的值是 %d\n", c );
				     printf("Line 4 - a 的值是 %d\n", a );
				   
				     printf("先运算后赋值：\n");
				     a = 10;
				     c = ++a; 
				     printf("Line 5 - c 的值是 %d\n", c );
				     printf("Line 6 - a 的值是 %d\n", a );
				     a = 10;
				     c = --a; 
				     printf("Line 7 - c 的值是 %d\n", c );
				     printf("Line 8 - a 的值是 %d\n", a );
				   
				  }
				  ```
				  运算结果  
				  ```
				  先赋值后运算：
				  Line 1 - c 的值是 10
				  Line 2 - a 的值是 11
				  Line 3 - c 的值是 10
				  Line 4 - a 的值是 9
				  先运算后赋值：
				  Line 5 - c 的值是 11
				  Line 6 - a 的值是 11
				  Line 7 - c 的值是 9
				  Line 8 - a 的值是 9
				  ```
					- ^a++ 与 ++a 的区
			- ## 关系运算符
			  collapsed:: true
				- | 运算符 | 描述 | 实例 |
				  |---|---|---|
				  | == | 等于 | (a == b) 如果 a 等于 b 则条件为真 |
				  | != | 不等于 | (a != b) 如果 a 不等于 b 则条件为真 |
				  | > | 大于 | (a > b) 如果 a 大于 b 则条件为真 |
				  | < | 小于 | (a < b) 如果 a 小于 b 则条件为真 |
				  | >= | 大于或等于 | (a >= b) 如果 a 大于或等于 b 则条件为真 |
				  | <= | 小于或等于 | (a <= b) 如果 a 小于或等于 b 则条件为真 |
				  *实例*  
				  ```C
				  #include <stdio.h>
				   
				  int main()
				  {
				     int a = 21;
				     int b = 10;
				     int c ;
				   
				     if( a == b )
				     {
				        printf("Line 1 - a 等于 b\n" );
				     }
				     else
				     {
				        printf("Line 1 - a 不等于 b\n" );
				     }
				     if ( a < b )
				     {
				        printf("Line 2 - a 小于 b\n" );
				     }
				     else
				     {
				        printf("Line 2 - a 不小于 b\n" );
				     }
				     if ( a > b )
				     {
				        printf("Line 3 - a 大于 b\n" );
				     }
				     else
				     {
				        printf("Line 3 - a 不大于 b\n" );
				     }
				     /* 改变 a 和 b 的值 */
				     a = 5;
				     b = 20;
				     if ( a <= b )
				     {
				        printf("Line 4 - a 小于或等于 b\n" );
				     }
				     if ( b >= a )
				     {
				        printf("Line 5 - b 大于或等于 a\n" );
				     }
				  }
				  ```
				  *当上面的代码被编译和执行时，它会产生下列结果：*  
				  ```
				  Line 1 - a 不等于 b
				  Line 2 - a 不小于 b
				  Line 3 - a 大于 b
				  Line 4 - a 小于或等于 b
				  Line 5 - b 大于或等于 a
				  ```
			- ## 逻辑运算符
			  collapsed:: true
				- | 运算符 | 描述 | 实例 |
				  |---|---|---|
				  | && | 逻辑与运算符 | (a && b) 如果 a 和 b 都为真,则条件为真 |
				  | II | 逻辑或运算符 | (a II b) 如果 a 和 b 至少有一个为真,则条件为真 |
				  | ! | 逻辑非运算符 | !(a && b) 将条件的真假值取反 |
				  *注I是竖线，markdown转义不了*  
				  *实例*  
				  ```c
				  #include <stdio.h>
				   
				  int main()
				  {
				     int a = 5;
				     int b = 20;
				     int c ;
				   
				     if ( a && b )
				     {
				        printf("Line 1 - 条件为真\n" );
				     }
				     if ( a || b )
				     {
				        printf("Line 2 - 条件为真\n" );
				     }
				     /* 改变 a 和 b 的值 */
				     a = 0;
				     b = 10;
				     if ( a && b )
				     {
				        printf("Line 3 - 条件为真\n" );
				     }
				     else
				     {
				        printf("Line 3 - 条件为假\n" );
				     }
				     if ( !(a && b) )
				     {
				        printf("Line 4 - 条件为真\n" );
				     }
				  }
				  ```
				  *结果*  
				  ````
				  Line 1 - 条件为真
				  Line 2 - 条件为真
				  Line 3 - 条件为假
				  Line 4 - 条件为真
				  ```
			- ## 位运算符
			  collapsed:: true
				- 假设变量 **A** 的值为 60，变量 **B** 的值为 13，则：
				  | 运算符 | 描述 | 实例 |
				  |---|---|---|
				  | & | 对两个操作数的每一位执行逻辑与操作，如果两个相应的位都为 1，则结果为 1，否则为 0。 | (A & B) 将得到 12，即为 0000 1100 |
				  | I | 对两个操作数的每一位执行逻辑或操作，如果两个相应的位都为 0，则结果为 0，否则为 1。 | (A I B) 将得到 61，即为 0011 1101 |
				  | ^ | 对两个操作数的每一位执行逻辑异或操作，如果两个相应的位值相同，则结果为 0，否则为 1。 | (A ^ B) 将得到 49 ，即为 0011 0001 |
				  | ~ | 对操作数的每一位执行逻辑取反操作，即将每一位的 0 变为 1，1 变为 0。 | (~A ) 将得到 -61 ，即为 1100 0011，一个有符号二进制数的补码形式。 |
				  | << | 将操作数的所有位向左移动指定的位数。左移 n 位相当于乘以 2 的 n 次方。二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000 |
				  | >> | 将操作数的所有位向右移动指定的位数。右移 n 位相当于除以 2 的 n 次方。二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111 |
				  *注1是竖线，markdown转义不了*  
				  *实例*  
				  ```c
				  #include <stdio.h>
				   
				  int main()
				  {
				   
				     unsigned int a = 60;    /* 60 = 0011 1100 */  
				     unsigned int b = 13;    /* 13 = 0000 1101 */
				     int c = 0;           
				   
				     c = a & b;       /* 12 = 0000 1100 */ 
				     printf("Line 1 - c 的值是 %d\n", c );
				   
				     c = a | b;       /* 61 = 0011 1101 */
				     printf("Line 2 - c 的值是 %d\n", c );
				   
				     c = a ^ b;       /* 49 = 0011 0001 */
				     printf("Line 3 - c 的值是 %d\n", c );
				   
				     c = ~a;          /*-61 = 1100 0011 */
				     printf("Line 4 - c 的值是 %d\n", c );
				   
				     c = a << 2;     /* 240 = 1111 0000 */
				     printf("Line 5 - c 的值是 %d\n", c );
				   
				     c = a >> 2;     /* 15 = 0000 1111 */
				     printf("Line 6 - c 的值是 %d\n", c );
				  }
				  ```
				  *结果*  
				  ````
				  Line 1 - c 的值是 12
				  Line 2 - c 的值是 61
				  Line 3 - c 的值是 49
				  Line 4 - c 的值是 -61
				  Line 5 - c 的值是 240
				  Line 6 - c 的值是 15
				  ```
			- ## 赋值运算符
			  collapsed:: true
				- | 运算符 | 描述 | 实例 |
				  |---|---|---|
				  | = | 简单赋值运算符 | a = b 将b的值赋给a |
				  | += | 加法赋值运算符 | a += b 等同于 a = a + b |
				  | -= | 减法赋值运算符 | a -= b 等同于 a = a - b |
				  | *= | 乘法赋值运算符 | a *= b 等同于 a = a * b |
				  | /= | 除法赋值运算符 | a /= b 等同于 a = a / b |
				  | %= | 取模赋值运算符 | a %= b 等同于 a = a % b |
				  | &= | 位与赋值运算符 | a &= b 等同于 a = a & b |
				  | ^= | 位异或赋值运算符 | a ^= b 等同于 a = a ^ b |
				  | <<= | 左移赋值运算符 | a <<= 2 等同于 a = a << 2 |
				  | >>= | 右移赋值运算符 | a >>= 2 等同于 a = a >> 2 |
				  *实例*  
				  ```c
				  #include <stdio.h>
				   
				  int main()
				  {
				     int a = 21;
				     int c ;
				   
				     c =  a;
				     printf("Line 1 - =  运算符实例，c 的值 = %d\n", c );
				   
				     c +=  a;
				     printf("Line 2 - += 运算符实例，c 的值 = %d\n", c );
				   
				     c -=  a;
				     printf("Line 3 - -= 运算符实例，c 的值 = %d\n", c );
				   
				     c *=  a;
				     printf("Line 4 - *= 运算符实例，c 的值 = %d\n", c );
				   
				     c /=  a;
				     printf("Line 5 - /= 运算符实例，c 的值 = %d\n", c );
				   
				     c  = 200;
				     c %=  a;
				     printf("Line 6 - %%= 运算符实例，c 的值 = %d\n", c );
				   
				     c <<=  2;
				     printf("Line 7 - <<= 运算符实例，c 的值 = %d\n", c );
				   
				     c >>=  2;
				     printf("Line 8 - >>= 运算符实例，c 的值 = %d\n", c );
				   
				     c &=  2;
				     printf("Line 9 - &= 运算符实例，c 的值 = %d\n", c );
				   
				     c ^=  2;
				     printf("Line 10 - ^= 运算符实例，c 的值 = %d\n", c );
				   
				     c |=  2;
				     printf("Line 11 - |= 运算符实例，c 的值 = %d\n", c );
				   
				  }
				  ```
				  *结果*  
				  ````
				  Line 1 - =  运算符实例，c 的值 = 21
				  Line 2 - += 运算符实例，c 的值 = 42
				  Line 3 - -= 运算符实例，c 的值 = 21
				  Line 4 - *= 运算符实例，c 的值 = 441
				  Line 5 - /= 运算符实例，c 的值 = 21
				  Line 6 - %= 运算符实例，c 的值 = 11
				  Line 7 - <<= 运算符实例，c 的值 = 44
				  Line 8 - >>= 运算符实例，c 的值 = 11
				  Line 9 - &= 运算符实例，c 的值 = 2
				  Line 10 - ^= 运算符实例，c 的值 = 0
				  Line 11 - |= 运算符实例，c 的值 = 2
				  ```
			- ## 杂项运算符
			  collapsed:: true
				- | 运算符 | 描述 | 实例 |
				  |---|---|---|
				  | sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。 |
				  | & | 返回变量的地址。 | &a; 将给出变量的实际地址。 |
				  | * | 指向一个变量。 | *a; 将指向一个变量。 |
				  | ? : | 条件表达式 | 如果条件为真 ? 则值为 X : 否则值为 Y |
				  *实例*  
				  ```c
				  #include <stdio.h>
				  
				  int main()
				  {
				   int a = 4;
				   short b;
				   double c;
				   int* ptr;
				  
				   /* sizeof 运算符实例 */
				   printf("Line 1 - 变量 a 的大小 = %lu\n", sizeof(a) );
				   printf("Line 2 - 变量 b 的大小 = %lu\n", sizeof(b) );
				   printf("Line 3 - 变量 c 的大小 = %lu\n", sizeof(c) );
				  
				   /* & 和 * 运算符实例 */
				   ptr = &a;    /* 'ptr' 现在包含 'a' 的地址 */
				   printf("a 的值是 %d\n", a);
				   printf("*ptr 是 %d\n", *ptr);
				  
				   /* 三元运算符实例 */
				   a = 10;
				   b = (a == 1) ? 20: 30;
				   printf( "b 的值是 %d\n", b );
				  
				   b = (a == 10) ? 20: 30;
				   printf( "b 的值是 %d\n", b );
				  }
				  ```
				  *结果*  
				  ````
				  Line 1 - 变量 a 的大小 = 4
				  Line 2 - 变量 b 的大小 = 2
				  Line 3 - 变量 c 的大小 = 8
				  a 的值是 4
				  *ptr 是 4
				  b 的值是 30
				  b 的值是 20
				  ```
				- c
			- ## 操作符优先级
			  collapsed:: true
				- C语言中的操作符具有不同的优先级，优先级高的操作符先于优先级低的操作符进行求值。以下是一些常用的C操作符的优先级从高到低的顺序：
				  
				  1. 括号：`()`，括号中的表达式具有最高的优先级。
				  
				  2. 后缀运算符：`++`，`--`，这些运算符用于增加或减少变量的值。
				  
				  3. 前缀运算符：`++`，`--`，`+`，`-`，`!`，`~`，这些运算符用于在运算之前执行一元操作。
				  
				  4. 乘法、除法和取模运算符：`*`，`/`，`%`，这些运算符用于执行乘法、除法和取模操作。
				  
				  5. 加法和减法运算符：`+`，`-`，这些运算符用于执行加法和减法操作。
				  
				  6. 移位运算符：`<<`，`>>`，这些运算符用于执行位级别的左移和右移操作。
				  
				  7. 关系运算符：`<`，`<=`，`>`，`>=`，这些运算符用于比较两个值之间的关系。
				  
				  8. 相等性运算符：`==`，`!=`，这些运算符用于比较两个值是否相等。
				  
				  9. 位运算符：`&`，`|`，`^`，这些运算符用于执行位级别的与、或和异或操作。
				  
				  10. 逻辑运算符：`&&`，`||`，这些运算符用于执行逻辑与和逻辑或操作。
				  
				  11. 条件运算符：`?:`，这个运算符用于根据一个条件选择执行两个不同的表达式之一。
				  
				  12. 赋值运算符：`=`，这个运算符用于将右侧的值赋给左侧的变量。
				  
				  请根据具体的需求和表达式的结构合理地使用操作符，并可以使用括号来明确优先级。
			- ## 隐式类型转换
			  collapsed:: true
				- C语言中的隐式类型转换是指在某些特定的表达式中，编译器会自动将一个数据类型转换为另一个数据类型，而无需显式地指定类型转换操作。
				  
				  隐式类型转换一般遵循以下几个规则：
				  
				  1. 小类型向大类型的转换：在表达式中，较小的数据类型会自动地隐式转换为较大的数据类型。例如，将一个字符赋值给一个整型变量时，字符类型会自动转换为整型。
				  
				  2. 整数类型的提升：在表达式中，低精度的整数类型会自动提升为高精度的整数类型。例如，将一个短整型和一个整型相加时，短整型会自动提升为整型。
				  
				  3. 浮点数类型的提升：在表达式中，低精度的浮点数类型会自动提升为高精度的浮点数类型。例如，将一个单精度浮点数和一个双精度浮点数相加时，单精度浮点数会自动提升为双精度浮点数。
				  
				  4. 混合类型的转换：如果一个表达式中包含了不同类型的操作数，则编译器会自动进行类型转换，使得两个操作数的类型相同。在这种情况下，编译器通常会将较低精度的类型转换为较高精度的类型。
				  
				  需要注意的是，虽然C语言支持隐式类型转换，但有时候隐式类型转换可能会导致意想不到的结果或错误。因此，在编写代码时，最好显式地指定类型转换操作，以避免隐式类型转换可能引发的问题。
			- [C 运算符 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-operators.html)
		- # 第6章 指针
		  collapsed:: true
			- ## 什么是指针？
			  collapsed:: true
				- 指针是一种变量，它存储了另一个变量的内存地址。换句话说，它指向（或引用）另一个变量。通过使用指针，我们可以直接访问和操作指向的内存位置上的数据。指针在程序中是非常有用的，特别是在需要动态分配内存、传递大型数据结构或者实现数据结构如链表、树等时。在C、C++等编程语言中，指针是一个重要的概念。
			- ## 指针和指针类型
			  collapsed:: true
				- ### 指针类型
				  collapsed:: true
					- 在C语言中,指针是一种数据类型,用于存储其他对象的地址。
					  常见的指针类型包括:
					  1. 指向整数的指针
					  int *ptr;
					  这里ptr是一个指向整型值的指针。
					  
					  2. 指向字符的指针
					  char *ptr;
					  这里ptr是一个指向字符的指针。
					  
					  3. 指向数组的指针
					  int arr[5];
					  int (*ptr)[5];
					  这里ptr是一个指向数组arr的指针。
					  
					  4. 指向函数的指针
					  int func();
					  int (*ptr)();
					  这里ptr是一个指向func函数的指针。
					  
					  5. 指向void类型的通用指针
					  void *ptr;
					  void指针可以指向任何其他类型的对象。
					  
					  指针保存地址而不是值本身。通过解引用操作(*)可以访问指针指向的实际对象。指针操作需要小心,以免造成buffer overflow等安全问题。
					-
					-
					-
					-
					-
				- ### 指针+-整数
				  collapsed:: true
					- 指针加减整数在C语言中有特殊含义,主要用于数组或字符串访问。
					  
					  当指针加减整数时,实际上是对指针指向的地址值进行加减操作。
					  
					  具体规则如下:
					  指针+整数:表示指针向后移动若干个单位(单位根据指针类型而定)。比如char指针单位为1字节,int指针单位为4字节。
					  指针-整数:表示指针向前移动若干个单位。
					  
					  例如:
					  
					  ```c
					  int arr[5];
					  int *p = arr;
					  
					  p++; // p指向arr的下一个元素 
					  p += 2; // p指向arr的第3个元素
					  
					  p--; // p指向arr的第2个元素
					  p -= 1; // p指向arr的第一个元素
					  ```
					  
					  指针加减负数与正数效果相同,只是方向相反。
					  
					  这个操作很常见于数组或字符串遍历中的循环迭代。比如:
					  
					  ```c 
					  for(p=arr; p<arr+5; p++) {
					  // do something
					  }
					  ```
					  
					  所以指针加减整数在C语言中主要用于数组与字符串的引用和操作。如果您有任何其他疑问,请告诉我。
				- ### C指针的解引用
				  collapsed:: true
					- C语言中的指针解引用是一种操作，用于访问指针所指向的内存位置上存储的数据。解引用操作符 "*" 是用来间接访问指针所指向的内存位置上的值。
					  
					  以下是一些关于指针解引用的示例：
					  
					  1. 声明一个整型指针，并将其指向一个整型变量：
					  ```c
					  int num = 10;
					  int *ptr = &num;
					  ```
					  
					  2. 通过指针解引用操作符来访问指针所指向的值：
					  ```c
					  int value = *ptr;  // value = 10
					  ```
					  
					  3. 修改指针所指向的值：
					  ```c
					  *ptr = 20;  // num的值变为20
					  ```
					  
					  4. 通过指针解引用来修改指针指向的值：
					  ```c
					  int num2 = 30;
					  ptr = &num2;  // 修改指针的指向为num2的地址
					  *ptr = 40;  // num2的值变为40
					  ```
					  
					  需要注意的是，在解引用操作之前，指针必须指向一个有效的内存地址，否则可能会导致未定义的行为或错误。
			- ## 野指针
			  collapsed:: true
				- ### C 野指针
				  collapsed:: true
					- C 野指针是指未初始化或已被释放的指针，它们指向了内存中的随机位置，这是一种极其危险的错误。野指针通常会导致程序崩溃、无法预测的行为以及内存泄漏。
					  
					  在使用指针时，应确保指针被正确初始化并指向有效的内存位置。使用野指针可能会导致访问无效内存，导致程序崩溃或产生不可预测的结果。
					  
					  避免野指针的最佳实践包括：
					  1. 初始化指针：确保指针指向有效的内存位置，可以通过给指针赋予一个有效的地址或使用动态内存分配函数（如malloc）来实现。
					  2. 及时释放指针：当指针不再需要时，要确保及时释放它所指向的内存。使用free函数释放通过动态内存分配函数分配的内存。
					  3. 避免重复释放：确保每个指针只被释放一次，重复释放可能导致不可预测的结果。
					  4. 避免使用已释放的指针：在指针被释放后，避免再次使用它，因为这可能会导致程序崩溃或不可预测的结果。
					  
					  总之，在C语言中，处理指针时要非常小心，确保正确地初始化、使用和释放指针，以避免引入野指针导致的潜在问题。
				- ### C 野指针成因
				  collapsed:: true
					- 主要有以下几个原因可能导致野指针产生:  
					  1. 指针未初始化  
					  如果在使用指针前忘记对其进行初始化,指针将指向随机地址,从而成为野指针。 
					  ```c
					  int* ptr;
					  *ptr = 10; // ptr points to random address
					  ````
					  2. 错误的指针声明 
					  如指针的类型与实际对象类型不匹配,或者对指针赋值时类型不匹配,可能导致指针指向非法地址。
					  ````
					  char* ptr;
					  int x = 10;
					  ptr = &x; // ptr points to address of int
					  ````
					  
					   3. 内存管理错误  
					  如使用free或者delete释放已经释放或没有申请的内存块,或使用free释放栈上内存等,会导致原指针指向野地址。
					  ```` 
					  int* p = malloc(sizeof(int));
					  free(p);
					  *p = 20; // p points to freed memory
					  ````
					  
					   4. 越界访问数组  
					  如果使用指针访问数组中超出范围的元素,指针将指向无效内存。 
					  ````
					  int arr[5];
					  int* p = &arr[10]; // index out of bounds
					  ````
					  
					  5. 函数返回局部变量地址 
					  函数返回指针时,如果该指针指向的是函数内的局部变量,出了函数作用域该内存就会释放,但指针还未改变。 
					  ````
					  int* func() {
					  int x = 10;
					  return &x; // x goes out of scope
					  }
					  ````
					  
					   6. 引用已经销毁的对象  
					  如指针指向一个只在特定作用域内有效的对象,一旦出了作用域,该对象就释放了,但指针还在使用。 
					  ````
					  int* p = new int();
					  delete p;
					  *p = 20; // p points to deleted object
					  ````
					  
					   7. 复用指针  
					  在指针指向一个对象后,未将其初始化,而是直接用于指向其他对象,旧对象地址泄漏。  
					  ````
					  int* p = new int(10);
					  p = new int(20); // old int is leaked
					  ````
					  
					  总之,指针使用不当最易造成野指针问题。重点就是指针必须清晰指向有效内存区域。
					-
					-
					-
				- ### C如何避免野指针
				  collapsed:: true
					- 在C语言编程中，有一些常见的问题可以通过一些方法来避免：
					  
					  1. 缓冲区溢出：正确使用字符串和数组的函数（例如`strcpy`、`strcat`等）可以避免缓冲区溢出。另外，使用安全版本的函数（例如`strcpy_s`、`strcat_s`）可以提供更多的保护。
					  
					  2. 内存泄漏：在分配内存之后，务必在不再需要时对其进行释放。使用`free`函数来释放动态分配的内存，确保没有任何未释放的内存块。
					  
					  3. 未初始化变量：确保在使用变量之前将其初始化，以避免意外的行为。在声明变量时，将其初始化为合理的默认值。
					  
					  4. 空指针引用：在使用指针之前，始终检查指针是否为NULL。例如，可以使用条件语句（如`if`语句）来检查指针是否为NULL，以避免使用空指针引发崩溃错误。
					  
					  5. 多线程问题：如果在多线程环境中编程，遵循正确的同步和互斥机制是很重要的。使用互斥锁或信号量来保护共享资源，以确保对其进行正确的访问和操作。
					  
					  6. 整数溢出：了解变量的数据范围，并在进行数学运算时进行适当的检查和处理。使用合适的类型来存储数据，以避免整数溢出问题。
					  
					  7. 未处理的错误：及时检测和处理可能发生的错误，以确保程序能够正确处理异常情况。使用错误处理机制（如返回错误代码或抛出异常），并相应地处理这些错误。
					  
					  通过遵循这些最佳实践和规范，可以帮助您在C语言编程中避免一些常见问题和错误。
			- ## 指针减指针
			  collapsed:: true
				- 在 C 语言中，指针减指针是一种操作，可以用来计算两个指针之间的元素个数。具体而言，如果有两个指针 `p1` 和 `p2`，它们指向同一个数组中的不同元素，那么 `p2 - p1` 的结果将返回它们之间的元素个数，而不是字节数。
				  
				  这是因为在 C 语言中，指针间的减法操作会计算两个指针之间存储单元的个数，而不是它们之间的字节数。这对于数组操作非常有用，因为数组中的元素在内存中是连续存储的。
				  
				  需要注意的是，两个指针需要满足一定的条件才能进行减法操作。首先，这两个指针必须指向同一个数组对象中的元素，否则减法操作将是未定义的行为。此外，结果应该存储在一个整数类型的变量中，因为返回的是元素个数。
				  
				  下面是一个例子，展示了 C 语言中指针减指针操作的使用方式：
				  
				  ```c
				  #include <stdio.h>
				  
				  int main() {
				      int arr[] = {1, 2, 3, 4, 5};
				      int *p1 = &arr[1];
				      int *p2 = &arr[4];
				  
				      // 计算指针之间的元素个数
				      int elements = p2 - p1;
				  
				      printf("p2 - p1 = %d\n", elements); // 输出: p2 - p1 = 3
				  
				      return 0;
				  }
				  ```
				  
				  在上述代码中，`p1` 指向 `arr[1]`，`p2` 指向 `arr[4]`，通过计算 `p2 - p1`，可以得到 `arr[4]` 与 `arr[1]` 之间的元素个数为 3。
			- ## 指针和数组
			  collapsed:: true
				- 指针与数组在C语言中关系很紧密,是掌握C语言的两个重要概念。这里总结几点指针与数组之间的关系:
				  1. 数组名可以看作是指向第一个元素的指针。例如:
				  ```c
				  int array[5];
				  int *ptr = array; //array就是地址值&array[0]
				  ```
				  
				  2. 使用数组下标访问元素等同于使用指针访问元素。例如:
				  ```c 
				  array[i] == *(array + i)
				  ```
				  
				  3. 可以通过指针访问整个数组。例如遍历数组:
				  ```c
				  for(int *p=array; p<array+5; p++) {
				  //使用指针p访问每个元素
				  }
				  ```
				  
				  4. 向指针增加或者减少整数,可以实现数组元素相对偏移的访问。
				  5. 数组作为函数参数等同于把其地址传递给函数。函数内通过指针来操作数组。
				  6. 动态内存分配返回的也是指向内存首地址的指针,很方便使用指针操作动态数组。
				  总之,C语言中的数组本质上就是一段连续的内存,数组名就是首元素的地址。指针提供了一种统一和便捷的方式来操作数组中的所有元素。掌握这两者关系和对应的操作方法,是学习C语言的要点。如果还有任何问题,请告诉我。
			- ## 二级指针
			  collapsed:: true
				- 二级指针是指指针的指针，也称为指向指针的指针。在C语言中，可以用二级指针来间接地访问或修改一个变量的值。二级指针通过存储指针的地址来指向一个指针变量，从而可以通过两次间接引用来访问或修改指向的变量。
				  
				  使用二级指针可以在函数中改变传递给它的指针变量的值。通过传递指向指针的指针作为参数，可以在函数内部修改指针的值，并且这个修改会在函数外部生效。
				  
				  例如，假设有一个整型变量和一个指向整型变量的指针变量。我们可以声明一个指向指针的指针，将其指向指针变量的地址。通过二级指针，我们可以访问或修改指向的整型变量的值。
				  
				  二级指针的定义和使用如下示例：
				  
				  ```c
				  #include <stdio.h>
				  
				  void updateValue(int **pptr) {
				    **pptr = 20;
				  }
				  
				  int main() {
				    int number = 10;
				    int *ptr = &number;
				    int **pptr = &ptr;
				  
				    printf("Before: %d\n", **pptr);
				    
				    updateValue(&ptr);
				  
				    printf("After: %d\n", **pptr);
				  
				    return 0;
				  }
				  ```
				  
				  这个程序会输出：
				  
				  ```
				  Before: 10
				  After: 20
				  ```
				  
				  通过引用二级指针，我们可以在`updateValue`函数中修改指针`ptr`所指向的整型变量的值，使其从10变为20。在函数外部，我们通过`**pptr`来访问修改后的值。
			- ## 指针数组
			  collapsed:: true
				- 指针数组是一个包含指针变量的数组，每个指针变量指向一个特定类型的数据。实际上，指针数组是一种存储多个指针的数据结构。
				  
				  以C语言为例，以下是一个指针数组的示例：
				  
				  ```C
				  #include <stdio.h>
				  
				  int main() {
				      int a = 10;
				      int b = 20;
				      int c = 30;
				  
				      int* ptrArr[3]; // 声明一个指针数组，包含三个指针变量
				  
				      ptrArr[0] = &a; // 第一个指针指向变量a
				      ptrArr[1] = &b; // 第二个指针指向变量b
				      ptrArr[2] = &c; // 第三个指针指向变量c
				  
				      printf("Value of a: %d\n", *ptrArr[0]); // 打印a的值
				      printf("Value of b: %d\n", *ptrArr[1]); // 打印b的值
				      printf("Value of c: %d\n", *ptrArr[2]); // 打印c的值
				  
				      return 0;
				  }
				  ```
				  
				  在上述示例中，`ptrArr`是一个包含三个指针变量的指针数组。每个指针存储了相应变量的地址。通过访问指针数组中的指针，并使用解引用运算符(`*`)可以访问到存储在其指向的变量中的值。最后，打印了变量a、b和c的值，并输出到控制台。
		- # 第 7 章 结构体
		  collapsed:: true
			- ## 结构体的声明
			  collapsed:: true
				- ### 什么是结构体
				  collapsed:: true
					- 结构体是C语言中的一种自定义的数据类型，用于将不同类型的数据组合在一起，形成一个逻辑上相关的数据单元。结构体可以包含多个成员，每个成员可以是不同的数据类型，比如整型、字符型、浮点型等。结构体的每个成员可以被单独访问，也可以作为一个整体进行操作。
					  
					  结构体可以用来定义复杂的数据结构，例如表示一个学生的信息或者一个汽车的属性。通过定义结构体，可以方便地管理和维护这些数据。
					  
					  结构体的定义通常在函数外部，用关键字`struct`加上类型名称来声明。可以使用`.`操作符来访问结构体的成员变量，直接为成员变量赋值或者从成员变量中获取值。
					  
					  例如，下面是一个表示学生信息的结构体定义：
					  ```c
					  struct student {
					     char name[20];
					     int age;
					     float gpa;
					  };
					  ```
					  通过这个结构体，可以定义一个学生对象，设置和获取其属性：
					  ```c
					  struct student s1;
					  strcpy(s1.name, "John");
					  s1.age = 18;
					  s1.gpa = 3.5;
					  ```
					  结构体可以帮助我们更好地组织和管理数据，提高程序的可读性和扩展性。
				- ### 结构的声明
				  collapsed:: true
					- C语言中，可以使用`struct`关键字来声明结构。结构能够用于定义用户自定义的数据类型，它可以包含多个不同类型的变量。
					  例如：
					  ```c
					  struct Person {
					      char name[50];
					      int age;
					      float height;
					  };
					  ```
					  这里，代码定义了一个名为`Person`的结构，它包含了一个`name`字符串数组、一个`age`整数和一个`height`浮点数。
				- ### 结构成员的类型
				  collapsed:: true
					- C语言中，结构体的成员可以是各种数据类型，包括基本数据类型和其他结构体类型。常见的C结构成员类型包括：
					  
					  1. 基本数据类型：例如整型（int、short、long）、浮点型（float、double）、字符型（char）、枚举等。
					  2. 指针类型：可以指向其他数据类型的指针，如整型指针、字符型指针等。
					  3. 数组类型：可以包含多个相同类型的元素的数据结构。
					  4. 结构体类型：可以在结构体中包含其他结构体作为成员。
					  5. 联合类型：可以在联合中定义多个不同类型的成员，但同一时间只能使用其中一个成员。
					  6. 枚举类型：可以定义一组值的集合，每个值都可以用一个标识符表示。
					  
					  此外，C语言还提供了一些特定的类型修饰符，如const和volatile，用于对结构体成员进行修饰。这些修饰符可以控制成员的不可变性或可变性以及优化方面的行为。
					  
					  总之，C语言提供了丰富的数据类型选择，可以根据需求选择合适的类型作为结构体的成员。
				- ### 结构体变量的定义和初始化
				  collapsed:: true
					- 结构体变量的定义和初始化是在编程中创建和设置结构体实例的过程。
					  
					  要定义一个结构体变量，首先需要声明结构体的类型。结构体类型通常在代码的开头被定义，并描述了结构体的成员变量的名称和类型。
					  
					  例如，我们要定义一个描述学生的结构体：
					  
					  ```c
					  struct Student {
					    int id;
					    char name[50];
					    int age;
					  };
					  ```
					  
					  上述代码定义了一个名为"Student"的结构体类型，包含三个成员变量：id，name和age。
					  
					  接下来，我们可以声明并初始化结构体变量。有两种常见的方法来完成这个任务：
					  
					  1. 直接在声明结构体变量时进行初始化：
					  
					  ```c
					  struct Student student1 = {1, "John Doe", 20};
					  ```
					  
					  上述代码创建了一个名为"student1"的结构体变量，其id为1，name为"John Doe"，age为20。
					  
					  2. 先声明结构体变量，然后通过逐个赋值的方式进行初始化：
					  
					  ```c
					  struct Student student2;
					  student2.id = 2;
					  strcpy(student2.name, "Jane Smith");
					  student2.age = 21;
					  ```
					  
					  上述代码首先声明了一个名为"student2"的结构体变量，然后通过分别赋值来初始化变量的各个成员。
					  
					  无论使用哪种方式，定义并初始化结构体变量后，我们就可以在程序中使用这些变量及其成员了。
			- ## C结构体成员的访问
			  collapsed:: true
				- 结构体成员的访问可以使用点（.）操作符或箭头（->）操作符，具体取决于访问的结构体的类型。
				  
				  如果结构体的实例是通过定义变量来创建的，使用点操作符来访问其成员。例如，假设有以下定义的结构体：
				  
				  ```c
				  struct Person {
				    char name[20];
				    int age;
				  };
				  ```
				  
				  创建一个结构体实例并访问其成员的示例代码如下：
				  
				  ```c
				  struct Person p1; // 创建一个名为p1的Person结构体实例
				  strcpy(p1.name, "John"); // 访问name成员并进行赋值
				  p1.age = 25; // 访问age成员并进行赋值
				  printf("Name: %s, Age: %d", p1.name, p1.age); // 访问name和age成员并输出
				  ```
				  
				  如果结构体的实例是通过指针来创建的，使用箭头操作符来访问其成员。例如，创建指向结构体的指针并访问其成员的示例代码如下：
				  
				  ```c
				  struct Person *ptr; // 创建一个指向Person结构体的指针
				  ptr = &p1; // 将指针指向p1结构体实例
				  
				  strcpy(ptr->name, "John"); // 访问name成员并进行赋值
				  ptr->age = 25; // 访问age成员并进行赋值
				  printf("Name: %s, Age: %d", ptr->name, ptr->age); // 访问name和age成员并输出
				  ```
			- ## C 结构体传参
			  collapsed:: true
				- 在 C 语言中，可以通过结构体来传递参数。结构体是一种用户自定义的数据类型，可以包含不同类型的数据成员。通过结构体传参可以将多个相关的数据打包在一起，然后一次性传递给函数。
				  
				  要在函数中传递结构体作为参数，可以使用以下两种方式：
				  
				  1. 传递结构体的实例：
				  
				     ```c
				     // 定义结构体
				     struct Person {
				         char name[20];
				         int age;
				     };
				  
				     // 函数定义
				     void printPerson(struct Person p) {
				         printf("Name: %s\n", p.name);
				         printf("Age: %d\n", p.age);
				     }
				  
				     // 使用结构体参数调用函数
				     int main() {
				         // 创建结构体实例
				         struct Person john;
				         strcpy(john.name, "John");
				         john.age = 30;
				  
				         // 调用函数并传递结构体实例
				         printPerson(john);
				  
				         return 0;
				     }
				     ```
				  
				  2. 传递结构体指针：
				  
				     ```c
				     // 定义结构体
				     struct Person {
				         char name[20];
				         int age;
				     };
				  
				     // 函数定义
				     void printPerson(struct Person* p) {
				         printf("Name: %s\n", p->name);
				         printf("Age: %d\n", p->age);
				     }
				  
				     // 使用结构体指针参数调用函数
				     int main() {
				         // 创建结构体实例
				         struct Person john;
				         strcpy(john.name, "John");
				         john.age = 30;
				  
				         // 调用函数并传递结构体指针
				         printPerson(&john);
				  
				         return 0;
				     }
				     ```
				  
				  无论是传递结构体实例还是指针，都可以在函数内部访问结构体的成员。传递结构体实例时，会进行值拷贝；而传递结构体指针时，在函数内部可以修改结构体的值。根据实际需求，选择适合的方式进行结构体的传参。
				- ### 结构体参数传递时有没有什么性能上的考虑？
					- 结构体作为参数传递时,有一些性能相关的考虑:
					  ^^传值 vs 传址^^:如果结构体较大,传值会因为值拷贝带来更高的性能开销。这时应该选择传址,也就是传结构体变量的地址。
					  
					  ^^指针 vs 整个结构^^:如果只需要读取结构体部分成员,可以选择传递指向这个结构体的指针,而不传递整个大结构体。这样可以减少参数传递量。
					  
					  ^^const限定符^^:如果函数内不需要修改结构体内容,可以使用const限定符声明结构体指针参数为常量指针,让编译器优化代码。
					  
					  ^^结构体指针 vs 结构体本身^^:如果结构体较小,直接传递结构体而不是其地址,可以避免指针引用额外开销。
					  
					  ^^注册寄存器^^:如果结构体较小(一般小于等于2个寄存器可以存放的大小),直接用值传递会更高效,因为被优化为直接通过寄存器传递。
					  
					  ^^缓存利用^^:避免传大结构体打乱缓存使用,可以提高性能。可以尽量按缓存行传递,减少缓存冲突。
					  
					  总体来说,传值传址要结合结构体大小和函数实际需要来权衡,巧妙利用const和缓存也有利于优化性能。这在一些需要高性能的场景下很重要。
	- **C++**
	- **Java**
- **C/C++刷题**
	- # **语法题**
		- # 经典永不过时
		  collapsed:: true
			- ## 求最大公约数的几种方法
			  collapsed:: true
				- ### 循环
				  collapsed:: true
					- *这是最简单的方法*
					  ```c
					  int main() {
					  	int a;
					  	int b;
					  	printf("请输入两个正整数：");
					  	scanf("%d %d", &a, &b);
					  	int i = 0;
					  	int m = 0;
					  	for (i = 1; i <= a && i <= b; i++) {
					  		if (a % i == 0 && b % i == 0) {
					  			m = i;
					  		}
					  	}
					  	printf("最大公约数为:%d\n", m);
					  		return 0;
					  }
					  ```
				- ### 九章算术—更相减损法
				  collapsed:: true
					- >判断a和b那个大,然后大数就减去小数的,再将减去得到的值赋予大数的位置,继续判断,直至两数相等,这时,a=b=最大公约数
					  
					  * 适用于两数相差不大也不小
					  
					  例:
					  
					  如果a>b,则a=a-b;
					  
					  如果吧b>a,则b=b-a;
					  
					  当a,b相等时,最大公约数就是a或b(a,b相等)
					  
					  ```c
					  int main()
					  {
					  	int a, b;
					  	scanf("%d %d", &a, &b);
					  	while (a != b)
					  	{
					  		if (a > b)
					  			a -= b;
					  		else
					  			b -= a;
					  	}
					  	printf("%d", a);
					  }
					  ````
					  时间复杂度 = **O (log (max (a, b)))**
					  算法优缺点:很稳定，但是数据大了就很慢
					  比较平衡的算法,避免了模运算,且算法性能平稳.
				- ### 单相取余法
				  collapsed:: true
					- >先判断a,b那个大,再用a和b的对小的取余,如果结果不为0,则让小的数-1,直至结果为0.
					  
					  
					    * 适用于两数相差较大,且其中一个数在数轴上离0比较近 
					  
					  ```c
					  int main()
					  {
					  	int a, b;
					  	scanf("%d %d", &a, &b);
					  	int n = a > b ? b : a; //最小值
					  	while (a % n != 0 || b % n != 0)
					  		--n;
					  	printf("%d", n);
					  }
					  ```
					  优点:算法设计简单且稳定,时间复杂度 = **O(min(a,b))<O(log(max(a,b)))**所以比更相减损发快
					  缺点:因为时间复杂度 = **O(min(a,b))**,所以最小值越大,计算越慢
				- ### 欧几里得——辗转相除法
				  collapsed:: true
					- >让两个数中的大数对小数取余,再将小数赋予大数,结果赋予小数,重复以上动作直至两数其中一个数为零,那么另一个就是最大公约数
					  
					  ```c
					  //辗转相除法
					  int main() {
					  	int a;
					  	int b;
					  	printf("请输入两个正整数：");
					  	scanf("%d %d", &a, &b);
					  	int k = 0;
					  	while (k = a % b) {
					  		a = b;
					  		b = k;
					  	}
					  	printf("最大公约数为:%d\n", b);
					  	return 0;
					  }
					  ```
					  优点:时间复杂度 = O(logn)适用于大部分范围
					  缺点:如果遇到相差比较大的数,计算起来就会开始慢了
					-
				- ### 函数递归法
				  collapsed:: true
					- >通过函数调用自身达到求最大公约数的目的,运行速度快,但是不稳定
					  
					  
					  **适用于两数相差较小时求最大公约数.**
					  ```c
					  int fin(int a, int b)
					  {
					  	if (a > b)
					  		fin(a - b, b);
					  	else if (a < b)
					  		fin(b - a, a);
					  	else
					  		return a;
					  }
					   
					  int main()
					  {
					  	int a, b;
					  	scanf("%d %d", &a, &b);
					  	printf("%d", fin(a,b));
					  }
					  ```
			- ## 质数
			- ## 回文系列
			  collapsed:: true
				- ### 判断是不是回文数
				  ```c
				  #include<stdio.h>
				  
				  int main()
				  {
				  	int i, j, k=0;
				  	scanf("%d", &i);
				  	j = i;
				  	while (j) //j!=0可以简写成 j
				  	{
				  		k = k * 10 + j % 10;
				  		j /= 10;
				  	}
				  	if (k == i) printf("%d 是回文数\n", i);
				  	else printf("%d 不是回文数\n", i);
				  	return 0;
				  }
				  ```
				- ### 输出[n,m]之间的回文数
				  ```c
				  #include<stdio.h>
				  int palindromic(int n, int m)
				  {
				  	int i, j, k, count = 0;
				  	for (i = n; i <= m; i++)
				  	{
				  		k = 0; j = i;
				  		while (j)
				  		{
				  			k = k * 10 + j % 10;    
				  			j /= 10;
				  		}
				  		if (k == i) count++; //计数
				  		if (k == i && count == 1)
				  			printf("%d", k); //第一个数前面不要加’，‘
				  		if (k == i && count != 1)
				  			printf(",%d", k); //在数之前加’，‘，为了防止最后有个’，‘
				  	}
				  }
				  
				  int main()
				  {
				  	int n, m;
				  	scanf("%d %d", &n, &m);
				  	palindromic(n, m);
				  	return 0;
				  }
				  
				  ```
				-
			- ## 斐波那契
			  collapsed:: true
				- ### 用for循环来求斐波那契数列
				  collapsed:: true
					- ```c
					  #include<iostream>
					  using namespace std;
					  int main()
					  {
					  int n;
					  cin >> n;
					  int a=1, b=1;
					  int i = 1;
					  for (i = 1; i <= n - 1; i++)
					  {
					  int c = a + b;
					  a = b;
					  b = c;
					  }
					  cout << a << endl;
					  return 0;
					  }
					  ```
				- ### 用函数来求斐波那契数列
				  collapsed:: true
					- ```c
					  #include<iostream>
					  using namespace std;
					  const int N = 100010;
					  int fbnq(int n)
					  {
					  	if (n == 1 || n == 2) return 1;
					  	if (n > 2)
					  		return (fbnq(n - 1) + fbnq(n - 2));
					  }
					  int main()
					  {
					  int n;
					  cin >> n;
					  cout << fbnq(n) << endl;
					  }
					  ```
				- ### 使用数组实现求斐波那契数列的第 N项
				  collapsed:: true
					- ```c
					  #include <iostream>
					  #include <algorithm>
					  
					  using namespace std;
					  
					  int main()
					  {
					      int n;
					      int f[100];
					  
					      cin >> n;
					  
					      f[0] = 0, f[1] = 1;
					      for (int i = 2; i <= n; i ++ ) f[i] = f[i - 1] + f[i - 2];
					  
					      cout << f[n] << endl;
					  
					      return 0;
					  }
					  ```
		- # 循环语句
		  collapsed:: true
			- ## 打印菱形
			  collapsed:: true
				- >输入一个奇数 n ，输出一个由 * 构成的 n  阶实心菱形。
				  
				  ```c
				  #include <iostream>
				  #include<cmath>
				  
				  using namespace std;
				  
				  int main()
				  {
				      int n;
				      cin >> n;
				  
				      int cx = n / 2, cy = n / 2;
				  
				      for (int i = 0; i < n; i++)
				      {
				          for (int j = 0; j < n; j++)
				              if (abs(i - cx) + abs(j - cy) <= n / 2)
				                  cout << '*';
				              else cout << ' ';
				          cout << endl;
				      }
				  
				      return 0;
				  }
				  
				  //曼哈顿距离
				  //空心菱形 == n/2
				  ```
			- ## 完全数
			  collapsed:: true
				- ```C++
				  #include<iostream>
				  #include<cstdio>
				  #include<cmath>
				  
				  using namespace std;
				  
				  int main()
				  {
				      int n;
				      cin >> n;
				      while (n--)
				      {
				          int x;
				          cin >> x;
				  
				          int sum = 0;
				          for (int i = 1; i <= sqrt(x); i++)
				              if (x % i == 0)
				              {
				                  if (i < x) sum += i; //如果x为1，防止加入本身
				                  if (i != x / i && x / i < x) sum += x / i;//防止加入两次相同的数 
				                //x / i < x，根据数学关系式，可以转换成 i > 1,就是，这里就是可以换成 i !=1 ,
				              }
				          if (sum == x) cout << x << " is perfect" << endl;
				          else cout << x << " is not perfect" << endl;
				      }
				      return 0;
				  }
				  
				  ```
				-
		- # 判断语句
		  collapsed:: true
			- ## 游戏时间
			  collapsed:: true
				- 读取两个整数 $A$ 和 $B$，表示游戏的开始时间和结束时间，以小时为单位。
				  
				  然后请你计算游戏的持续时间，已知游戏可以在一天开始并在另一天结束，最长持续时间为 $24$ 小时。
				  
				  如果 $A$ 与 $B$ 相等，则视为持续了 $24$ 小时。
				- #### 输入格式
				  
				  共一行，包含两个整数 $A$ 和 $B$。
				- #### 输出格式
				  
				  输出格式为 `O JOGO DUROU X HORA(S)`，其中 $X$ 为游戏持续时间。
				- #### 数据范围
				  
				  $0 \le A,B \le 23$
				- #### 输入样例1：
				  
				  ```
				  16 2
				  ```
				- #### 输出样例1：
				  
				  ```nginx
				  O JOGO DUROU 10 HORA(S)
				  ```
				- #### 输入样例2：
				  
				  ```
				  0 0
				  ```
				- #### 输出样例2：
				  
				  ```nginx
				  O JOGO DUROU 24 HORA(S)
				  ```
				- #### 输入样例3：
				  
				  ```
				  2 16
				  ```
				- #### 输出样例3：
				  
				  ```nginx
				  O JOGO DUROU 14 HORA(S)
				  ```
				- ### 题解
					- 我的代码
					  ```C++
					  #include<iostream>
					  
					  using namespace std;
					  
					  int main()
					  {
					      int h1,m1,h2,m2;
					      cin>>h1>>m1>>h2>>m2;
					      if(h1==h2&&m1==m2) cout<<"O JOGO DUROU 24 HORA(S) E 0 MINUTO(S)"<<endl;
					      else{
					          if(m1<=m2)
					          {
					              if(h1<=h2) //注意是小于等于，否则错误
					                cout<<"O JOGO DUROU "<<h2-h1<<" HORA(S) "<<"E "<<m2-m1<<" MINUTO(S)"<<endl;
					              else 
					                cout<<"O JOGO DUROU "<<24+h2-h1<<" HORA(S) "<<"E "<<m2-m1<<" MINUTO(S)"<<endl;
					          }
					          else
					          {
					              int m = 60 + m2 - m1;
					              if(h1<h2) cout<<"O JOGO DUROU "<<h2-h1-1<<" HORA(S) "<<"E "<<m<<" MINUTO(S)"<<endl;
					              else cout<<"O JOGO DUROU "<<24+h2-h1-1<<" HORA(S) "<<"E "<<m<<" MINUTO(S)"<<endl;
					  
					          }
					      }
					      return 0;
					  }
					  ```
					- 大佬的代码
					  ```C++
					  #include <iostream>
					  using namespace std;
					  int main()
					  {
					      int a,b,c,d,x,y;
					      cin >> a >> b >> c >> d;
					      b = a * 60 + b;
					      d = c * 60 + d;
					      //下面，如果是 20:20 10:10 则d-b是负数，（-610）,然而真实过去的时间是《互补》的另一半，（1400-610）=790 
					      a = (d-b+24*60)%(24*60);
					      a = (a) ? (a) : (24*60);
					      printf("O JOGO DUROU %d HORA(S) E %d MINUTO(S)",a/60,a%60);
					      return 0;
					  }
					  ```
			-
		- # 数组
		  collapsed:: true
			- ## 数组顺时针旋转
			  collapsed:: true
				- >输入一个 n，再输入 n个整数。将这个数组顺时针旋转 k(k≤n)次，最后将结果输出。旋转一次是指：将最左边的数放到最右边。
				- 循环
				  ```c
				  #include<iostream>
				  
				  using namespace std;
				  
				  int main()
				  {
				  	int a[100];
				  	int n, k;//n是输入几个数，k是旋转次数
				  	cin >>n >> k;
				  	for (int i = 0; i < n; i++) cin >> a[i];
				  	while (k--)
				  	{
				  		int t = a[n - 1]; //t存储最后一个数
				  		for (int i = n - 2; i >= 0; i--) a[i + 1] = a[i]; //后一个等于前一个
				  		a[0] = t; //第一个变成最后一个
				  
				  	}
				  	for (int i = 0; i < n; i++) cout << a[i] << ' ';
				  	return 0;
				  }
				  //时间复杂度为O(n^2)
				  ````
				- reverse函数
				  ```c
				  #include<iostream>
				  #include<algorithm>
				  
				  using namespace std;
				  
				  int main()
				  {
				  	int a[100];
				  	int n, k;//n是输入几个数，k是旋转次数
				  	cin >> n >> k;
				  	for (int i = 0; i < n; i++) cin >> a[i];
				  	reverse(a, a + n);
				  	reverse(a, a + k);
				  	reverse(a + k, a + n);
				  
				  	for (int i = 0; i < n; i++) cout << a[i] << ' ';
				  	return 0;
				  }
				  //时间复杂度为0(n)
				  ```
			- ## 数组排序
			  collapsed:: true
				- 输入 n 个数，将这 n个数按从小到大的顺序输出。
				- ```c
				  #include<iostream>
				  #include<algorithm>
				  
				  using namespace std;
				  
				  int main()
				  {
				  	int n;
				  	int a[100];
				  	cin >> n;
				  	for (int i = 0; i < n; i++) cin >> a[i]; //输入n个数
				  	for (int i = 0; i < n; i++)
				  	{
				  		for (int j = i + 1; j < n; j++) 
				  		{
				  			if (a[i] > a[j]) swap(a[i], a[j]); //交换
				  		}	
				  		//里面的for循环的意思是先把a[i]变成从右往左最小的数
				  	}
				  	for (int i = 0; i < n; i++) cout << a[i] << ' ';
				  	cout << endl;
				  
				  	return 0;
				  }
				  ```
			- ## 计算2的N次方
			  collapsed:: true
				- ```c
				  #include <iostream>
				  #include <algorithm>
				  
				  using namespace std;
				  
				  int main()
				  {
				      int a[10000], size = 1, n;
				      a[0] = 1;
				  
				      cin >> n;
				      while (n -- )
				      {
				          int t = 0; //t是进位
				          for (int i = 0; i < size; i ++ )
				          {
				              t += a[i] * 2;
				              a[i] = t % 10;
				              t /= 10;
				          }
				          if (t) a[size ++ ] = t;
				      }
				  
				      for (int i = size - 1; i >= 0; i -- ) cout << a[i];
				      cout << endl;
				  
				      return 0;
				  }
				  
				  ```
				- ^^加注释版^^
				  ```c
				  #include <iostream>
				  
				  const int N = 10010;
				  
				  using namespace std;
				  
				  
				  int main() {
				      /*
				      T: O() 外部循环为n次，也就是n的幂次，内部循环为数字的长度，也就是 n\log_{10}{2} ， 因此复杂度为 n * (n\log_{10}{2})
				      S: O() 数字的长度  n\log_{10}{2}
				      idea:
				       构成要件：一个数组存储数字；一个全局变量记录进位【每次进位实质上就是将其向右移动一位】；一个局部变量。存储累乘，然后累加的数字；
				       基本逻辑：近似于斐波那契数列的逻辑，每次乘以前面的数字，然后存储，这里累乘的是2，初始值是1；其中幂次n作为了外部循环
				      */
				      // 最低为数字是1，因为它乘以任何数都是任何数
				      int a[N] = { 1 };
				      int n;
				      cin >> n;
				      int m = 1;
				      // 输入的 n 是 2 的幂次，并非乘数
				      for (int i = 0; i < n; i++) {
				          int t = 0;
				          // 循环内的数字从低位不断被取出，这些数字都从左到右存放，也就是个位数在最左端，每次从数组a中读取个位十位，分别与 2 相乘
				          // 运算后把数字存回原数组
				          for (int j = 0; j < m; j++) {
				              t += a[j] * 2;
				              a[j] = t % 10;
				              t /= 10;
				          }
				          // 负责进位，for循环最后一个操作是 t / 10，由于乘以2，最大为19， 因此若商为1，必定进位1
				          if (t) a[m++] = 1;
				      }
				  
				      for (int i = m - 1; i >= 0; i--) cout << a[i];
				  
				      return 0;
				  }
				  ```
				-
			- ## 多项式卷积
			  collapsed:: true
				- 描述
				  >多项式卷积就是两个多项式的乘积。
				  假设有两个多项式分别为：
				  $f(x)=a_0+a_1x+a_2x^2+a_3x^3+...+a_{n-1}  x^{n-1}$
				  $g(x)=b_0+b_1x+b_2x^2+b_3x^3+...+b_{n-1}  x^{n-1}$
				  假设$F(x)=f(x)*g(x)$
				  则$F(x)=a_0b_0+（a_0b_1+a_1b_0)x+...+(\sum _{p+q=i}a_pb_q)x_i+...$
				  求给定$f(x)$和$g(x)$的前n项求$F(X)$的前n项系数
				- 输入
				  >第一行输入一个整数n
				  第二行包含n个整数，分别是$ a_0​、a_1​、a_2​…a_{n−1​}$
				  第三行包含n个整数，本别是 $b_0​、b_1​、b-2​…b_{n−1}​$
				  $1<n<10000$
				  $1≤a_1​、b_1​≤100$
				- 输出
				  >输出一行，即$F(x)$的前n项系数
				- 输入样例
				  ```
				  7
				  1 -1 -1 0 -1 1 -1 
				  1 1 1 1 1 1 1
				  ```
				- 输出样例
				  ```
				  1 0 -1 -1 -2 -1 -2 
				  ```
				- ### 多项式卷积
					- 以下是一个用C语言编写的程序，用于实现多项式卷积的功能。
					- ```c
					  #include <stdio.h>
					  #define MAX_SIZE 10000
					  // 多项式卷积函数
					  void polynomialConvolution(int n, int* A, int* B, int* C) {
					    int i, j;
					  for (i = 0; i < n; i++) {
					        C[i] = 0; // 初始化结果多项式的系数为0
					        for (j = 0; j <= i; j++) {
					            C[i] += A[j] * B[i - j]; // 计算卷积运算
					        }
					    }
					  }
					  int main() {
					    int n;
					    int A[MAX_SIZE];
					    int B[MAX_SIZE];
					    int C[MAX_SIZE];
					    int i;
					  // 读取输入的多项式长度n
					    scanf("%d", &n);
					  // 读取多项式A的系数
					    for (i = 0; i < n; i++) {
					        scanf("%d", &A[i]);
					    }
					  // 读取多项式B的系数
					    for (i = 0; i < n; i++) {
					        scanf("%d", &B[i]);
					    }
					  // 进行多项式卷积运算
					    polynomialConvolution(n, A, B, C);
					  // 输出结果多项式的系数
					    for (i = 0; i < n; i++) {
					        printf("%d ", C[i]);
					    }
					    printf("\n");
					   return 0;
					  }
					  ```
					- 你可以使用该程序来读取输入的多项式系数，并输出结果多项式的系数。注意，该程序假设输入的多项式长度相同（n相等）并且不超过最大长度限制（MAX_SIZE）。
			- ## 矩阵乘法
			  collapsed:: true
				- ![image.png](../../assets/image_1699609385428_0.png){:height 379, :width 749}
				- ```c++
				  #include <stdlib.h>
				  #include <stdio.h>
				  #include <algorithm>
				  #include <iostream>
				  #include <string.h>
				  #include <math.h>
				  using namespace std;
				  int a[205][205],b[205][205];
				  int ans[205][205];
				  int main()
				  {
				  	int m,s,n,i,j,k;
				  	cin>>m>>s>>n;
				  	for(i=0;i<m;i++)
				  		for(j=0;j<s;j++)
				  			cin>>a[i][j];
				  	for(i=0;i<s;i++)
				  		for(j=0;j<n;j++)
				  			cin>>b[i][j];
				  	for(i=0;i<m;i++)
				  		for(j=0;j<n;j++)
				  			for(k=0;k<s;k++)
				  				ans[i][j]+=a[i][k]*b[k][j];
				  	for(i=0;i<m;i++)
				  	{
				  		for(j=0;j<n;j++)
				  			{
				  				if(j==n-1)
				  				cout<<ans[i][j]<<endl;
				  				else
				  				cout<<ans[i][j]<<" ";
				  			}
				  	}
				      return 0;
				  }
				  ```
			- ## 找鞍点
			  collapsed:: true
				- ![image.png](../../assets/image_1699609481584_0.png)
				- ```c++
				  #include<stdio.h>
				  int main()
				  {
				  	int n, i, j, k, max, flag, a[6][6];//flag判断是否存在鞍点
				  	max = flag = 0;
				  	scanf("%d", &n);
				  	for(i=0; i<n; i++){
				  		for(j=0; j<n; j++){
				  			scanf("%d", &a[i][j]);
				  		}
				  	}
				  	for(i=0; i<n; i++){
				  		flag = 0;//注意每轮循环重置flag值
				  		for(j=0; j<n; j++){//找到第i行的极大值
				  			if(a[i][j]>=a[i][max]){//注意等号说明如果两个极大值取后一个
				  				max = j;
				  			}
				  		}
				  		for(k=0; k<n; k++){//在第max列寻找最小行
				  			if(a[i][max]>a[k][max]){//如果不是，记录flag并跳出循环
				  				flag = 1;
				  				break;
				  			}
				  		}
				  		if(!flag){//flag=0说明找到，输出并跳出
				  			printf("%d %d", i, max);
				  			break;
				  		}
				  	}
				  	if(flag){//循环结束后flag=1说明不存在鞍点
				  		printf("NONE");
				  	}
				  	return 0;
				  }
				  ```
			- ## 福到了
			  collapsed:: true
				- 描述
				  >“福”字倒着贴，寓意“福到”。不论到底算不算民俗，本题且请你编写程序，把各种汉字倒过来输出。这里要处理的每个汉字是由一个 N×N 的网格组成的，网格中的元素或者为字符`@`或者为空格。而倒过来的汉字所用的字符由裁判指定。
				- 输入
				  >输入在第一行中给出倒过来的汉字所用的字符、以及网格的规模 N （不超过100的正整数），其间以 1 个空格分隔；随后 N 行，每行给出 N 个字符，或者为`@`或者为空格。
				- 输出
				  >输出倒置的网格，如样例所示。但是，如果这个字正过来倒过去是一样的，就先输出`bu yong dao le`，然后再用输入指定的字符将其输出。
				- 输入样例 1
				  ```
				  $ 9
				   @  @@@@@
				  @@@  @@@ 
				   @   @ @ 
				  @@@  @@@ 
				  @@@ @@@@@
				  @@@ @ @ @
				  @@@ @@@@@
				   @  @ @ @
				   @  @@@@@
				  ```
				  输出样例 1
				  ```
				  $$$$$  $ 
				  $ $ $  $ 
				  $$$$$ $$$
				  $ $ $ $$$
				  $$$$$ $$$
				   $$$  $$$
				   $ $   $ 
				   $$$  $$$
				  $$$$$  $ 
				  ```
				- 输入样例 2
				  ```
				  & 3
				  @@@
				   @ 
				  @@@
				  ```
				  输出样例 2
				  ```
				  bu yong dao le
				  &&&
				   & 
				  &&&
				  ```
				- ### 答案
				  collapsed:: true
					- ```c
					  #include<stdio.h>
					  char s[105][105];
					  int main()
					  {
					      char c;
					      int n;
					      scanf("%c %d",&c,&n);
					      getchar();              //吞换行回车
					      for(int i=0;i<n;i++)
					      {
					          for(int j=0;j<n;j++)
					          {
					              scanf("%c",&s[i][j]);
					          }
					          getchar();          //吞换行回车
					      }
					      int flag=0;
					      for(int i=0;i<n;i++)
					      {
					          for(int j=0;j<n;j++)
					          {
					              if(s[i][j]!=s[n-i-1][n-j-1])        //对称
					              {
					                  flag=1;
					              }
					          }
					      }
					      if(!flag)
					      {
					          printf("bu yong dao le\n");
					      }
					      for(int i=0;i<n;i++)
					      {
					          for(int j=0;j<n;j++)
					          {
					              if(s[n-i-1][n-j-1] != ' ')
					              {
					                  printf("%c",c);
					              }
					              else
					              {
					                  printf(" ");
					              }
					          }
					          printf("\n");
					      }
					      return 0;
					  }
					  
					  ```
			- ## 删除数字
			  collapsed:: true
				- ![image.png](../../assets/image_1699609992412_0.png)
				- ```c
				  #include <stdio.h>
				  
				  void removeNumber(int arr[], int n, int target) {
				      int found = 0;
				      for (int i = 0; i < n; i++) {
				          if (arr[i] != target) {
				              if (found) {
				                  printf(" ");
				              }
				              printf("%d", arr[i]);
				              found = 1;
				          }
				      }
				      printf("\n");
				  }
				  
				  int main() {
				      int n;
				      while (~scanf("%d", &n) ) {
				          int arr[1001];
				          for (int i = 0; i < n; i++) {
				              scanf("%d", &arr[i]);
				          }
				          int target;
				          scanf("%d", &target);
				          removeNumber(arr, n, target);
				      }
				      return 0;
				  }
				  ```
			- ## 判断题
			  collapsed:: true
				- ![image.png](../../assets/image_1699613335883_0.png){:height 282, :width 749}
				- ```c
				  #include <stdio.h>
				  
				  int main()
				  {
				      int n , m;
				      scanf("%d%d",&n,&m);
				      int score[m];
				      int answer;
				      int right[m];
				      int getscore[n];
				      int scores = 0;
				      for(int i = 0; i < m ; i++)
				          scanf("%d",&score[i]);
				      for(int l = 0; l < m ; l++)
				          scanf("%d",&right[l]);
				      for(int k = 0; k < n; k++){
				          for (int j = 0; j < m;j++){
				              scanf("%d",&answer);
				          if (answer == right[j])
				               scores = scores + score[j];
				          }getscore[k] = scores;
				          }
				      printf("%d\n",getscore[0]);
				      for(int c = 1;c<n;c++)
				          printf("%d\n",getscore[c]-getscore[c-1]);
				    
				      
				      return 0;
				  }
				  ```
			- ## 阶乘计算
			  collapsed:: true
				- ![image.png](../../assets/image_1699613394844_0.png)
				- ```c++
				  #include<iostream>
				  using namespace std;
				  void f(int n)
				  {
				      if (n == 1)
				          cout << "1";
				      else
				      {
				          int a[100000], tail = 0, head = 0, p = 0;
				          a[0] = 1;
				          for (int i = 2; i <= n; i++) {
				              for (int j = head; j <= tail; j++)
				              {
				                  p = a[j] * i + p;
				                  a[j] = p % 10;
				                  p = p / 10;
				              }
				              while (p != 0)
				              {
				                  tail++;
				                  a[tail] = p % 10;
				                  p = p / 10;
				              }
				          }
				          for (int i = tail; i >= 0; i--)
				              cout << a[i];
				      }
				  }
				  int main()
				  {
				      int n;
				      cin >> n;
				      f(n);
				      return 0;
				  }
				  ```
			- ## 芯片测试
			  collapsed:: true
				- ![image.png](../../assets/image_1699613451071_0.png)
				- ```c
				  #include <stdio.h>
				  int n;
				  int a[20][20];
				  int num[20]={0};
				  int main ()
				  {
				  	int i,j;
				  	scanf("%d",&n);
				  	for(i=1;i<=n;i++)
				  		for(j=1;j<=n;j++)
				  		{
				  			scanf("%d",&a[i][j]);
				              if(a[i][j]==1)
				              {
				              	num[j]++;   //记录每一列的1 的个数 ，用于判断是否大于n/2 
				  			}
				  		}
				  		
				  	int flag=0;//设置输出格式 
				  	for(i=1;i<=n;i++)
				  	{
				  		if(num[i]>n/2)
				  		{
				  			if(flag==0)
				  			{
				  				printf("%d",i);
				  				flag=1;
				  			}
				  			else
				  				printf(" %d",i);
				  		}
				  	}
				  	return 0;
				  }
				  
				  ```
			- ## 数字黑洞
			  collapsed:: true
				- ![image.png](../../assets/image_1699613497035_0.png)
				- ```c
				  #include<stdio.h>
				  #include<string.h>
				  #include<stdlib.h>
				  int cmp1(const void *a, const void *b){
				      return *(char *)b - *(char *)a;//降序
				  }
				  
				  int cmp2(const void *a, const void *b){
				      return *(char *)a - *(char *)b;//降序
				  }
				  
				  void zero_padding(char a[],int n){
				      int i;
				      for (i=strlen(a);i<n;i++)
				          a[i] = '0';
				  }
				  
				  int main()
				  {
				      int temp,k,t,num = 0;
				  	char a[5],b[5];
				  	scanf("%s",a);
				  	if (atoi(a)!=6174)
				  	{
				  	    do{
				  	        k = 0;
				  	        zero_padding(a,4);
				  	        strcpy(b,a);
				  	        qsort(a,4,sizeof(char),cmp1);
				  	        qsort(b,4,sizeof(char),cmp2);
				  	        temp = atoi(a)-atoi(b);
				  	        t = temp;
				  	        while (temp!=0){
				  	            a[k++] = temp%10+48;
				  	            temp/=10;
				  	        }
				  	        num++;
				  	    }while (t!=6174);
				  	}
				  	printf("%d",num);
				  	return 0;
				  }
				  ```
			- ## 平方矩阵 I
			  collapsed:: true
				- **题目描述**
				  >输入整数 N，输出一个 N 阶的回字形二维数组。数组的最外层为 1，次外层为 2，以此类推。
				  
				  **输入格式**
				  >输入包含多行，每行包含一个整数 N。当输入行为 N=0 时，表示输入结束，且该行无需作任何处理。
				  
				  **输出格式**
				  >对于每个输入整数 N，输出一个满足要求的 N 阶二维数组。
				  每个数组占 N 行，每行包含 N 个用空格隔开的整数。
				  每个数组输出完毕后，输出一个空行。
				  
				  **数据范围**
				  >0≤N≤100
				  
				  **输入样例:**
				  ```
				  1
				  2
				  3
				  4
				  5
				  0
				  ```
				  **输出样例:**
				  ```
				  1
				  
				  1 1
				  1 1
				  
				  1 1 1
				  1 2 1
				  1 1 1
				  
				  1 1 1 1
				  1 2 2 1
				  1 2 2 1
				  1 1 1 1
				  
				  1 1 1 1 1
				  1 2 2 2 1
				  1 2 3 2 1
				  1 2 2 2 1
				  1 1 1 1 1
				  ```
				- ### 解法一(找规律法)
					- >①通过观察回字形矩阵, 矩阵关于对角线是左上方和右下方对称的
					  ②利用二维行列循环, 获取行列+1的最小值(即min(i + 1, j + 1)), 可得如下图形(例如n == 4):
					  1 1 1 1
					  1 2 2 2
					  1 2 3 3
					  1 2 3 4
					  可以看出未划横线部分（左上部分）满足题解,此时如果使图像沿着对角线翻转,再重合,即可求解答案
					  ③翻转图像,采用min(n - i, n - j)即可, 得到图像如下(例如n == 4):
					  4 3 2 1
					  3 3 2 1
					  2 2 2 1
					  1 1 1 1
					  ④进行图像的重合, 对应位置取最小值即可求解min(Left上, right下)
					- ```C++
					  #include <iostream>
					  #include <cmath>
					  
					  using namespace std;
					  
					  
					  int main(){
					      int n;
					  
					      while (cin >> n, n){
					  
					          for (int i = 0; i < n; i ++){
					              for(int j = 0; j < n; j ++){
					                  cout << min(min(i + 1, j + 1), min(n - i, n - j)) << " ";
					              }
					              cout << endl ;
					          }
					          cout << endl;
					      }
					  
					      return 0;
					  }
					  ```
				- ### 解法二（曼哈顿距离法）
				  collapsed:: true
					- >①当n为奇数时, 找取中间点n / 2分别于行i列j的距离的最大值(max(abs(n / 2 - i), abs(n / 2 - j))),可以的如下图形(例如n == 5):
					  2 2 2 2 2
					  2 1 1 1 2
					  2 1 0 1 2
					  2 1 1 1 2
					  2 2 2 2 2
					  ②观察结果, 随着回形越深入,内外围回形相差为1, 因此想到 (n + 1) / 2
					  ③当n为偶数时，采用同样的方法, 这里我们就让中心点在图形的中间位置 (n - 1) / 2.0, 再求解其分别于行i列j的距离的最大值(max(abs((n - 1) / 2.0 - i), abs((n - 1) / 2.0 - j)))
					  ④再考虑所得图形与实际结果相差值,这里我们依然设置(n + 1) / 2
					- ```c++
					  #include <iostream>
					  #include <cmath>
					  
					  using namespace std;
					  
					  int main(){
					      int n;
					      while(cin >> n, n ){
					  
					          for (int i = 0; i < n; i ++){
					              for (int j = 0; j < n; j ++){
					                  if (n % 2) 
					                      cout << (n + 1) / 2 - max(abs(n / 2 - i), abs(n / 2 - j)) << ' ';
					                  else
					                      cout << (n + 1) / 2.0 - max(abs((n - 1) / 2.0 - i), abs((n - 1) / 2.0 - j)) << ' ';
					              }
					              cout << endl;
					          }
					  
					          cout << endl;
					      }
					  
					      return 0;
					  }
					  
					  作者：Chuckie
					  链接：https://www.acwing.com/solution/content/71619/
					  来源：AcWing
					  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
					  ```
				- ### 解法三(利用蛇形矩阵求解)
				  collapsed:: true
					- >①设置一个计数器统计方向改变次数
					  ②设置变量res表示回形当前圈数
					  ③其他部分与蛇形矩阵相同
					  
					  ```c++
					  #include <iostream>
					  #include <cstring>
					  #include <cmath>
					  
					  using namespace std;
					  
					  const int N = 100 + 10;
					  int m[N][N];
					  
					  int main(){
					      int n;
					      int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
					  
					      while(cin >> n, n ){
					          memset(m, 0, sizeof m);
					          int d = 1, x = 0, y = 0;
					          int cnt = 0;  // 表示改变方向次数
					          int res = 1;  // 回形当前圈数
					          for (int i = 0; i < n * n; i ++){
					              int a = x + dx[d], b = y + dy[d];
					              m[x][y] = res;
					  
					              if (a < 0 || a >= n || b < 0 || b >= n || m[a][b]){
					                  d = (d + 1) % 4;
					                  a = x + dx[d], b = y + dy[d];
					                  cnt ++;
					                  if (!(cnt % 4)) res ++;
					              }
					              x = a, y = b;
					          }
					  
					          for (int i = 0; i < n; i ++){
					              for (int j = 0; j < n; j ++)
					                  cout << m[i][j] << ' ';
					              cout << endl;
					          }
					          cout << endl;
					      }
					  
					      return 0;
					  }
					  
					  ```
			- ## 平方矩阵 II
			  collapsed:: true
				- 输入整数 $N$，输出一个 $N$ 阶的二维数组。
				  
				  数组的形式参照样例。
				- ### 输入格式
				  
				  输入包含多行，每行包含一个整数 $N$。
				  
				  当输入行为 $N=0$ 时，表示输入结束，且该行无需作任何处理。
				- ### 输出格式
				  
				  对于每个输入整数 $N$，输出一个满足要求的 $N$ 阶二维数组。
				  
				  每个数组占 $N$ 行，每行包含 $N$ 个用空格隔开的整数。
				  
				  每个数组输出完毕后，输出一个空行。
				- ### 数据范围
				  
				  $0 \le N \le 100$
				- ### 输入样例：
				  
				  ```
				  1
				  2
				  3
				  4
				  5
				  0
				  ```
				- ### 输出样例：
				  
				  ```
				  1
				  
				  1 2
				  2 1
				  
				  1 2 3
				  2 1 2
				  3 2 1
				  
				  1 2 3 4
				  2 1 2 3
				  3 2 1 2
				  4 3 2 1
				  
				  1 2 3 4 5
				  2 1 2 3 4
				  3 2 1 2 3
				  4 3 2 1 2
				  5 4 3 2 1
				  ```
				- ### 题解
				  collapsed:: true
					- ```c++
					  #include<iostream>
					  
					  using namespace std;
					  
					  int main()
					  {
					      int n,q[100][100];
					      while(cin>>n,n)
					      {
					          for(int i =0;i<n;i++)
					          {
					              q[i][i]=1;
					              for(int j = i + 1,k = 2;j<n;j++,k++) q[i][j]=k;
					              for(int j = i +1,k=2;j<n;j++,k++) q[j][i] =k;
					          }
					          for(int i  = 0 ;i < n; i++)
					          {
					              for(int j = 0 ; j< n ;j++) cout<<q[i][j]<<' ';
					              cout<<endl;
					          }
					          cout<<endl;
					      }
					      return 0;
					  }
					  ```
			- ## 平方矩阵III
			  collapsed:: true
				- 输入整数 $N$，输出一个 $N$ 阶的二维数组 $M$。
				  
				  这个 $N$ 阶二维数组满足 $M[i][j] = 2^{i+j}$。
				  
				  具体形式可参考样例。
				- ### 输入格式
				  
				  输入包含多行，每行包含一个整数 $N$。
				  
				  当输入行为 $N=0$ 时，表示输入结束，且该行无需作任何处理。
				- ### 输出格式
				  
				  对于每个输入整数 $N$，输出一个满足要求的 $N$ 阶二维数组。
				  
				  每个数组占 $N$ 行，每行包含 $N$ 个用空格隔开的整数。
				  
				  每个数组输出完毕后，输出一个空行。
				- ### 数据范围
				  
				  $0 \le N \le 15$
				- ### 输入样例：
				  
				  ```
				  1
				  2
				  3
				  4
				  5
				  0
				  ```
				- ### 输出样例：
				  
				  ```
				  1
				  
				  1 2
				  2 4
				  
				  1 2 4
				  2 4 8
				  4 8 16
				  
				  1 2 4 8
				  2 4 8 16
				  4 8 16 32
				  8 16 32 64
				  
				  1 2 4 8 16
				  2 4 8 16 32
				  4 8 16 32 64
				  8 16 32 64 128
				  16 32 64 128 256
				  ```
				- ### 题解
					- ```cpp
					  #include<iostream>
					  #include<cmath>
					  
					  using namespace std;
					  
					  int main()
					  {
					      long long int n ,a[15][15];
					      while(cin>>n,n)
					      {
					          for(int i = 0;i<n;i++)
					          {
					              a[i][0] = pow(2,i);
					              cout<<a[i][0]<<' ';
					              for(int j = 1 ;j<n;j++)
					              {
					                  a[i][j]=2*a[i][j-1];
					                  cout<<a[i][j]<<' ';
					              }
					              cout<<endl;
					          }
					          cout<<endl;
					      }
					      
					      return 0;
					  }
					  ```
			- ## 蛇形矩阵
			  collapsed:: true
				- >输入两个整数 n 和 m，输出一个 n 行 m 列的矩阵，将数字 11 到 n×m 按照回字蛇形填充至矩阵中。具体矩阵形式可参考样例。
				- #### 输入格式
				  >输入共一行，包含两个整数 n和 m。
				- #### 输出格式
				  >输出满足要求的矩阵。
				  矩阵占 n行，每行包含 m个空格隔开的整数。
				- #### 数据范围
				  >1≤n,m≤100
				- #### 输入样例：
				  ```
				  3 3
				  ```
				- #### 输出样例：
				  ```
				  1 2 3
				  8 9 4
				  7 6 5
				  ```
				- ### 解法一 偏移量
				  collapsed:: true
					- ```c++
					  #include<iostream>
					  
					  using namespace std;
					  
					  int res[100][100];
					  
					  int main()
					  {
					      int n, m;
					      cin >> n >> m;
					      int dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 };
					      for (int x = 0, y = 0, d = 0, k = 1; k <= n * m; k++)
					      {
					          res[x][y] = k;
					          int a = x + dx[d], b = y + dy[d];
					          if (a < 0 || a >= n || b < 0 || b >= m || res[a][b])
					          {
					              d = (d + 1) % 4;
					              a = x + dx[d], b = y + dy[d];
					          }
					          x = a, y = b;
					      }
					      for (int i = 0; i < n; i++)
					      {
					          for (int j = 0; j < m; j++)
					          {
					              cout << res[i][j] << ' ';
					          }
					          cout << endl;
					      }
					      return 0;
					  
					  }
					  ```
				- ###
			- ## 蛇形矩阵II
				- 描述
				  >一个n行的蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。
				  第一行有n个数，接下来每行逐减。具体的规律参考样例。
				- 输入
				  >输入一个整数n(1≤n≤100)。
				- 输出
				  >输出n行的蛇形矩阵。
				- 输入样例 1
				  ```
				  5
				  ```
				  输出样例 1
				  ```
				  1 3 6 10 15
				  2 5 9 14
				  4 8 13
				  7 12
				  11
				  ```
				- 输入样例 2
				  ```
				  6
				  ```
				  输出样例 2
				  ```
				  1 3 6 10 15 21
				  2 5 9 14 20
				  4 8 13 19
				  7 12 18
				  11 17
				  16
				  ```
				- ### 解法1
				  collapsed:: true
					- ```cpp
					  #include <iostream>
					  
					  using namespace std;
					  
					  int main() {
					      int n, i, j, a = 1, b = 1, k;
					      cin >> n;
					  
					      for (i = 1; i <= n; i++) {
					          b = a;
					          a = a + i;
					          k = i + 1;
					  
					          for (j = i; j <= n; j++) {
					              if (j == n) {
					                  cout << b << endl;
					              } else {
					                  cout << b << ' ';
					              }
					              b += k;
					              k++;
					          }
					      }
					  
					      return 0;
					  }
					  ```
				- ### 解法2
					- ```cpp
					  #include<iostream>
					  
					  using namespace std;
					  
					  int main() {
					      int res[110][110], n;
					      int x, y, k = 1;
					      cin >> n;
					      for (int i = 0; i < n; i++) {
					          x = i, y = 0;
					          while (x >= 0 && y <= i) {
					              res[x][y] = k;
					              x--, y++;
					              k++;
					          }
					      }
					      for (int i = 0; i < n; i++) {
					          for (int j = 0; j < n - i; j++)
					              cout << res[i][j] << ' ';
					          cout << endl;
					      }
					  
					      return 0;
					  }
					  ```
					-
			-
		- # 函数
		  collapsed:: true
			- ## 亲和数对
			  collapsed:: true
				- ![image.png](../../assets/image_1699008369053_0.png){:height 320, :width 749}
				- ```c
				  #include<stdio.h>
				  #include<math.h>
				  
				  int getdivsum(int num)
				  {
				      int sum = 1; //1是真约数
				      for (int j = 2; j <= sqrt(num); j++) 
				      {
				          if (num % j == 0)
				          {
				              sum += j;
				              if (j != sqrt(num))
				                  sum += num / j;
				          }
				          
				      }
				      return sum;
				  }
				  
				  void qinhe(int a, int b)
				  {
				      for (int i = a; i <= b; i++)
				      {
				          int divsum = getdivsum(i);
				          if (divsum > i&&divsum <65535)
				          {
				              if (i == getdivsum(divsum))
				                  printf("%d,%d\n", i, divsum);
				  
				          }
				      }
				  }
				  
				  int main()
				  {
				  	int a, b;
				  	scanf("%d %d", &a, &b);
				      qinhe(a, b);
				  	return 0;
				  }
				  ````
			- ## 不变初心数
			  collapsed:: true
				- ![image.png](../../assets/image_1699008479095_0.png)
				- ```c
				  #include <stdio.h>
				  int main(){
				      int n,sum=0,i,t,j,a,f,c=0;
				      scanf("%d",&n);
				      for(i=0;i<n;i++){
				          scanf("%d",&a);
				          t=a;
				          sum=0;
				          while(t){
				              sum+=t%10;
				              t/=10;
				          }
				          f=sum;
				          //printf("%d ",f);
				          c=0;
				          for(j=2;j<=9;j++){
				              t=a*j;
				              sum=0;
				              while(t){
				                sum+=t%10;
				                t/=10;
				              }
				              if(sum==f) c++;
				          }
				          if(c==8) printf("%d\n",f);
				          else     printf("NO\n");
				      }
				      return 0;
				  }
				  ```
			- ## 核桃的数量
			  collapsed:: true
				- ![image.png](../../assets/image_1699008554079_0.png){:height 366, :width 749}
				- ```c
				  #include<stdio.h>
				  
				  int findmax(int a,int b)
				  {
				  	if (a<b)
				  	{
				  		int temp = a;
				  		a = b;
				  		b = temp;
				  	}
				  	int num = b;
				  	while (num <= a * b)
				  	{
				  		if (num % a == 0 && num % b == 0) break;
				  		else num++;
				  		
				  	}
				  	return num;
				  }
				  
				  int main()
				  {
				  	int a, b, c;
				  	scanf("%d %d %d", &a, &b, &c);
				  	int num = findmax(a, b);
				  	num = findmax(num, c);
				  	printf("%d\n", num);
				  	return 0;
				  }
				  ```
			- ## 小于m的最大的10个素数
			  collapsed:: true
				- ![image.png](../../assets/image_1699008648211_0.png)
				- ```c
				  #include<stdio.h>
				  int main()
				  {    
				  int m,k,cnt=0;   
				  scanf("%d",&m);   
				  for(int i=m-1;i>1;i--)   
				     {       
				      for(k=2;k<i;k++)       
				      {            
				        if(i%k==0)            
				        break;        
				      }       
				       if(k>=i)        
				       {        
				       printf("%6d",i);   
				       cnt++;              
				       }         
				  if(cnt>=10)        
				  break;    
				  }    
				  return 0;
				  
				  ````
				-
			- ## 求组合数
			  collapsed:: true
				- ![image.png](../../assets/image_1699008726062_0.png)
				- ^^正确代码^^ 
				  ```c
				  #include <stdio.h>
				  
				  double fact(int n) {
				      double result = 1.0;
				      for (int i = 1; i <= n; i++) {
				          result *= i;
				      }
				      return result;
				  }
				  
				  int main() {
				      int m, n;
				      scanf("%d %d", &m, &n);
				  
				      double numerator = fact(n);
				      double denominator = fact(m) * fact(n - m);
				      double result = numerator / denominator;
				  
				      printf("result = %d\n", (int)result);
				  
				      return 0;
				  }
				  ````
				- ^^错误代码^^
				  ```c
				  //错误示范 
				  #include <stdio.h>
				  
				  long long fact(int n) {
				      if (n == 0 || n == 1) {
				          return 1;
				      }
				      else {
				          return n * fact(n - 1); //使用递归，在较大值的输入上可能溢出，改成循环
				      }
				  }
				  
				  int main() {
				      int n, m;
				      scanf("%d %d", &m, &n);
				      long long n_fact = fact(n); //溢出
				      long long m_fact = fact(m);
				      long long nm_fact = fact(n - m);
				      double result = (double)(n_fact) / (m_fact * nm_fact);
				      printf("result = %.0lf\n", result);
				      return 0;
				  }
				  //long long的最大值：9223372036854775807（>10^18）
				  //double: 8 byte = 64 bit 范围：1.79769e+308 ~ 2.22507e-308
				  //32的阶乘为2.631308369336935e+35
				  ````
			- ## 偶完全数
			  collapsed:: true
				- ![image.png](../../assets/image_1699008910204_0.png)
				- ```c
				  #include<stdio.h>
				  unsigned long long num[8]= {0};
				  void sushu(int n)
				  {
				      unsigned long long i,j,temp;
				      int k=1;
				      for(i=4;; i*=2)
				      {
				          temp=i-1;
				          int temp_0=sqrt((float)temp);//用开平方的方法减少循环次数
				          num[0]=3;//temp=3时不符合循环条件，单独列出
				          for(j=2; j<=temp_0; j++)
				          {
				              if(temp%j==0)
				                  break;
				              if(j==temp_0)
				              {
				                  num[k++]=temp;
				              }
				          }
				          if(k==n)
				              break;
				      }
				  }
				  int main()
				  {
				      int n;
				      unsigned long long m,ji;
				      while(scanf("%d",&n)!=EOF)
				      {
				          sushu(n);
				          m=(num[n-1]+1)/2;
				          ji=m*num[n-1];
				          printf("%llu=%llu*%llu\n",ji,m,num[n-1]);
				      }
				      return 0;
				  }
				  ````
			- ## 最大公约数
			  collapsed:: true
				- ![image.png](../../assets/image_1699009046317_0.png)
				- ```c
				  #include<stdio.h>
				  
				  int xcf(int a, int b)//辗转相除法
				  {
				      int r;
				      r = a % b;
				      while (r != 0)
				      {
				          a = b;
				          b = r;
				          r = a % b;
				      }
				      return b;
				  }
				  
				  int main()
				  {
				      int t;
				      scanf("%d", &t);
				      for (int i = 1; i <= t; i++) //可以替换成while(t--)
				      {
				          int a, b;
				          scanf("%d %d", &a, &b);
				          int result = xcf(a, b); // 保存最大公约数到result变量
				          printf("%d\n", result); // 输出result变量的值
				      }
				      return 0;
				  }
				  
				  ```
		- # 字符串
	- # **算法题**
- **算法与数据结构**
	- # 基础算法
		- ## **排序算法**
		  collapsed:: true
			- ## 冒泡排序
			  collapsed:: true
				- 冒泡排序是一种简单的排序算法，它通过多次遍历要排序的数列，比较相邻的元素，如果它们的顺序不正确就交换它们。这样，较大的元素就慢慢"浮"到数列的顶端，而较小的元素就慢慢沉到底部。
				- ![bubbleSort.gif](../../assets/bubbleSort_1700786910794_0.gif)
				- 以下是一个用C++编写的冒泡排序算法示例：
				  
				  ```cpp
				  #include <iostream>
				  using namespace std;
				  
				  void bubbleSort(int arr[], int n) {
				      for (int i = 0; i < n-1; i++) {
				          for (int j = 0; j < n-i-1; j++) {
				              if (arr[j] > arr[j+1]) swap(arr[j],arr[j-1]);
				          }
				      }
				  }
				  
				  int main() {
				      int arr[] = {64, 25, 12, 22, 11};
				      int n = sizeof(arr) / sizeof(arr[0]);
				  
				      bubbleSort(arr, n);
				  
				      cout << "排序后的数组: \n";
				      for (int i=0; i<n; i++) {
				          cout << arr[i] << " ";
				      }
				      return 0;
				  }
				  ```
				  
				  这段代码中，`bubbleSort`函数实现了冒泡排序算法，`main`函数中创建了一个整数数组，并对其进行排序。
			- ## 快速排序
			  collapsed:: true
				- 快速排序是一种常用的排序算法，它利用分治思想将一个大问题分解为较小的子问题来解决。该算法的基本思想是选择一个基准值，然后将数组中小于基准值的元素移到基准值的左边，大于基准值的元素移到基准值的右边。接着对基准值左右两边的子数组分别进行快速排序，直到整个数组有序为止。快速排序的平均时间复杂度为O(nlogn)，在大多数情况下表现良好。
				- ![quickSort.gif](../../assets/quickSort_1700788386782_0.gif)
				- 当然，这是一个快速排序的C++实现，并带有详细的注释：
				  
				  ```cpp
				  #include <iostream>
				  
				  using namespace std;
				  
				  const int N = 1000010;
				  
				  int q[N];
				  
				  void quick_sort(int q[], int l, int r)
				  {
				      if (l >= r) return; //注意是>=,否则会报错
				  
				      int i = l - 1, j = r + 1, x = q[l + r >> 1];
				      while (i < j)
				      {
				          do i ++ ; while (q[i] < x);
				          do j -- ; while (q[j] > x);
				          if (i < j) swap(q[i], q[j]);
				      }
				      quick_sort(q, l, j), quick_sort(q, j + 1, r);
				  }
				  
				  int main()
				  {
				      int n;
				      scanf("%d", &n);
				  
				      for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
				  
				      quick_sort(q, 0, n - 1);
				  
				      for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
				  
				      return 0;
				  }
				  ```
				  
				  这段代码实现了快速排序算法。在`quick_sort`函数中，我们使用分治法递归地对基准值左右两侧的子数组进行排序。
				- >*快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。*
				- [1.6 快速排序 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/quick-sort-2.html)
			- ## 归并排序
			  collapsed:: true
				- 归并排序是一种常见的排序算法，它采用分而治之的策略。它通过递归地将数组分成两半，然后对两个子数组分别进行排序，最后将它们合并成一个有序的数组。这个算法的关键步骤是合并操作，它将两个有序的子数组合并成一个更大的有序数组。由于归并排序的时间复杂度为O(n log n)，因此它在处理大型数据集时表现良好。
				- ![aHR0cDovL3d3dy5jeHl4aWFvd3UuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzEwLzE1NzEwNTgyODEtNDFiNGMzYjk5N2FmMmNhLmdpZg.gif](../../assets/aHR0cDovL3d3dy5jeHl4aWFvd3UuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzEwLzE1NzEwNTgyODEtNDFiNGMzYjk5N2FmMmNhLmdpZg_1700786662114_0.gif)
				- ```C++
				  #include <iostream>
				  
				  using namespace std;
				  
				  const int N = 1e6 + 10; //10010
				  
				  int a[N], tmp[N];
				  
				  void merge_sort(int q[], int l, int r)
				  {
				      if (l >= r) return;
				  
				      int mid = l + r >> 1;
				  
				      merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
				  
				      int k = 0, i = l, j = mid + 1;
				      while (i <= mid && j <= r)
				          if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
				          else tmp[k ++ ] = q[j ++ ];
				      while (i <= mid) tmp[k ++ ] = q[i ++ ];
				      while (j <= r) tmp[k ++ ] = q[j ++ ];
				  
				      for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
				  }
				  
				  int main()
				  {
				      int n;
				      scanf("%d", &n);
				      for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
				  
				      merge_sort(a, 0, n - 1);
				  
				      for (int i = 0; i < n; i ++ ) printf("%d ", a[i]);
				  
				      return 0;
				  }
				  ```
		- ## **查找算法**
		  collapsed:: true
			- ## 顺序查找
			  collapsed:: true
				- 顺序查找是一种简单的搜索算法，它按顺序逐个检查列表中的每个元素，直到找到目标元素为止。这种方法适用于较小的数据集，但对于较大的数据集来说，效率较低。如果需要频繁地执行搜索操作，可能需要考虑其他更高效的搜索算法，比如二分查找或哈希表。
				- ```C++
				  #include <iostream>
				  #include <cstdio>
				  
				  const int N = 100010;
				  
				  int st[N];
				  
				  using namespace std;
				  
				  int search(int st[], int key, int n) {
				      st[0] = key; //st[0]为监视哨，减少判定
				      int i = n;
				      while (st[i] != key) i--;
				      return i;
				  }
				  
				  int main() {
				      int n, m;
				      scanf("%d %d", &n, &m);
				      for (int i = 1; i <= n; i++) scanf("%d", &st[i]);
				      while (m--) {
				          int key;
				          scanf("%d", &key);
				          cout << search(st, key, n) << endl;
				      }
				      return 0;
				  }
				  ```
				- ## 二分查找
				  collapsed:: true
					- ## 整数二分
					  collapsed:: true
						- 整数二分（Integer Binary Search）是一种在有序整数数组中进行搜索的算法。它通过反复将搜索范围对半分割来逼近要查找的目标值，提高了搜索的效率。在每一步中，算法会将搜索范围缩小为左右两个子区间，然后根据目标值与子区间的中间值的大小关系，决定向左或向右子区间继续搜索。整数二分通常在需要快速搜索的情况下发挥作用，如查找特定整数或满足某种条件的整数等。
						- ### 整数二分算法模板
						  ```C++
						  bool check(int x) {/* ... */} // 检查x是否满足某种性质
						  
						  // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
						  int bsearch_1(int l, int r)
						  {
						      while (l < r)
						      {
						          int mid = l + r >> 1;
						          if (check(mid)) r = mid;    // check()判断mid是否满足性质
						          else l = mid + 1;
						      }
						      return l;
						  }
						  // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
						  int bsearch_2(int l, int r)
						  {
						      while (l < r)
						      {
						          int mid = l + r + 1 >> 1;
						          if (check(mid)) l = mid;
						          else r = mid - 1;
						      }
						      return l;
						  }
						  
						  ```
						- [【二分查找】详细图解_二分查找法流程图-CSDN博客](https://blog.csdn.net/qq_45978890/article/details/116094046)
					- ## 浮点数二分
					  collapsed:: true
						- 浮点数二分是一种通过二分搜索算法来处理浮点数的方法。在二分搜索过程中，我们尝试找到目标值（或其近似值）所在的范围。对于浮点数二分，我们可以设定一个精度范围，然后在每一步迭代中，根据当前范围内的中间值来更新搜索范围，直到达到所需的精度或找到目标值。这种方法常用于需要对浮点数进行搜索或优化的问题中。
						- ***模板***
						  
						  ```cpp
						  bool check(double x) {/* ... */} // 检查x是否满足某种性质
						  
						  double bsearch_3(double l, double r)
						  {
						      const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
						      while (r - l > eps)
						      {
						          double mid = (l + r) / 2;
						          if (check(mid)) r = mid;
						          else l = mid;
						      }
						      return l;
						  }
						  ```
						- ### 例题——数的三次方根
						  collapsed:: true
							- >给定一个浮点数 n，求它的三次方根。
							- #### 输入格式
							  >共一行，包含一个浮点数 n。
							- #### 输出格式
							  >共一行，包含一个浮点数，表示问题的解。
							  注意，结果保留 6 位小数。
							- #### 数据范围
							  >−10000≤n≤10000
							- #### 输入样例：
							  ```
							  1000.00
							  ```
							- #### 输出样例：
							  ```
							  10.000000
							  ```
							- #### 答案
								- ```cpp
								  #include<iostream>
								  
								  using namespace std;
								  
								  int main()
								  {
								      double x;
								      scanf("%lf",&x);
								      double l = -10000 , r = 10000;
								      while(r - l > 1e-8)
								      {
								          double mid = (l + r) / 2;
								          if(mid * mid *mid >= x) r =mid;
								          else l = mid;
								      }
								      printf("%lf",l);
								  }
								  ```
						-
				-
		- ## **高精度**
		  collapsed:: true
			- ## 高精度加法
			  collapsed:: true
				- 高精度加法是指在处理非常大的数字时，为了避免数字溢出或精度丢失，采用一种特殊的算法进行加法运算。通常采用字符串或数组表示数字，然后逐位进行加法计算，同时考虑进位的情况。这样可以确保对大数字进行准确的加法运算，而不会丢失精度。
				- ### ***高精度加法——模板***
				  collapsed:: true
					- ```cpp
					  // C = A + B, A >= 0, B >= 0
					  vector<int> add(vector<int> &A, vector<int> &B)
					  {
					      if (A.size() < B.size()) return add(B, A);
					  
					      vector<int> C;
					      int t = 0;
					      for (int i = 0; i < A.size(); i ++ )
					      {
					          t += A[i];
					          if (i < B.size()) t += B[i];
					          C.push_back(t % 10);
					          t /= 10;
					      }
					  
					      if (t) C.push_back(t);
					      return C;
					  }
					  ```
					-
				- ### 例题
					- 给定两个正整数（不含前导 $0$），计算它们的和。
					- #### 输入格式
					  
					  共两行，每行包含一个整数。
					- #### 输出格式
					  
					  共一行，包含所求的和。
					- #### 数据范围
					  
					  $1 \le 整数长度 \le 100000$
					- #### 输入样例：
					  
					  ```
					  12
					  23
					  ```
					- #### 输出样例：
					  
					  ```
					  35
					  ```
					- 题解
					  collapsed:: true
						- ```cpp
						  #include<iostream>
						  #include<vector>
						  
						  using namespace std;
						  
						  vector<int> add(vector<int> &A, vector<int> &B) {
						      vector<int> C;
						      int t = 0; //t用作进位
						      for (int i = 0; i < A.size() || i < B.size(); i++) {
						          if (i < A.size()) t += A[i];
						          if (i < B.size()) t += B[i];
						          C.push_back(t % 10);
						          t /= 10;
						      }
						      if (t) C.push_back(1);
						      return C;
						  }
						  
						  int main() {
						      string a, b;
						      vector<int> A, B;
						      cin >> a >> b;
						      for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
						      for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
						  
						      auto C = add(A, B);
						      for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
						  
						      return 0;
						  }
						  ```
			- ## 高精度减法
			  collapsed:: true
				- 可以使用高精度减法的方法来进行减法运算。这种方法通常涉及到使用数组或字符串来表示数字，并实现逐位的减法操作。通过逐位计算并处理借位，可以实现任意位数的高精度减法。在编程中，可以使用算法来实现高精度减法，确保准确性和精度。
				- ### ***高精度减法——模板***
				  collapsed:: true
					- ```cpp
					  // C = A - B, 满足A >= B, A >= 0, B >= 0
					  vector<int> sub(vector<int> &A, vector<int> &B)
					  {
					      vector<int> C;
					      for (int i = 0, t = 0; i < A.size(); i ++ )
					      {
					          t = A[i] - t;
					          if (i < B.size()) t -= B[i];
					          C.push_back((t + 10) % 10);
					          if (t < 0) t = 1;
					          else t = 0;
					      }
					  
					      while (C.size() > 1 && C.back() == 0) C.pop_back();
					      return C;
					  }
					  ```
				- ### 例题
				  collapsed:: true
					- 给定两个正整数（不含前导 $0$），计算它们的差，计算结果可能为负数。
					- #### 输入格式
					  
					  共两行，每行包含一个整数。
					- #### 输出格式
					  
					  共一行，包含所求的差。
					- #### 数据范围
					  
					  $1 \le 整数长度 \le 10^5$
					- #### 输入样例：
					  
					  ```
					  32
					  11
					  ```
					- #### 输出样例：
					  
					  ```
					  21
					  ```
					- ### *题解*
					  collapsed:: true
						- ```cpp
						    #include <iostream>
						    #include<vector>
						    
						    using namespace std;
						    
						    bool cmp(vector<int> &A, vector<int> &B) //判断A是否大于等于B
						    {
						        if (A.size() != B.size()) return A.size() > B.size();
						        for (int i = A.size() - 1; i >= 0; i--)
						            if (A[i] != B[i]) return A[i] > B[i];
						        return true;
						    }
						    
						    vector<int> sub(vector<int> &A, vector<int> &B) {
						        vector<int> C;
						        for (int i = 0, t = 0; i < A.size(); i++) //t是借位
						        {
						            t = A[i] - t;
						            if (i < B.size()) t -= B[i]; //判断B的长度是否符合要求
						            C.push_back((t + 10) % 10);
						            if (t < 0) t = 1;
						            else t = 0;
						        }
						        while (C.size() > 1 && C.back() == 0) C.pop_back(); //去掉前导0
						        return C;
						    }
						    
						    int main() {
						        string a, b;
						        vector<int> A, B;
						        cin >> a >> b;
						        for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
						        for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
						    
						        if (cmp(A, B)) {
						            auto C = sub(A, B);
						            for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
						        } else {
						            auto C = sub(B, A);
						            printf("-");
						            for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
						        }
						    
						    
						        return 0;
						    }
						  ```
			- ## 高精度乘法
			  collapsed:: true
				- 高精度乘法是指对于大数相乘时所采用的一种计算方法，通常用于处理超过计算机固定数据类型表示范围的大数。这种计算方法可以通过分割大数并使用适当的算法来有效地进行乘法运算。常用的算法有竖式乘法和Karatsuba算法等。使用高精度乘法可以确保计算的精度，并且适用于需要处理大整数的场景，比如加密算法、金融领域和科学计算等。
				- ### ***高精度乘低精度——模板***
				  collapsed:: true
					- ```cpp
					  // C = A * b, A >= 0, b >= 0
					  vector<int> mul(vector<int> &A, int b)
					  {
					      vector<int> C;
					  
					      int t = 0;
					      for (int i = 0; i < A.size() || t; i ++ )
					      {
					          if (i < A.size()) t += A[i] * b;
					          C.push_back(t % 10);
					          t /= 10;
					      }
					  
					      while (C.size() > 1 && C.back() == 0) C.pop_back(); //去除前导0
					  
					      return C;
					  }
					  ```
					  和高精度加法类似
				- ### 例题
				  collapsed:: true
					- 给定两个非负整数（不含前导 $0$） $A$ 和 $B$，请你计算 $A \times B$ 的值。
					- #### 输入格式
					  
					  共两行，第一行包含整数 $A$，第二行包含整数 $B$。
					- #### 输出格式
					  
					  共一行，包含 $A \times B$ 的值。
					- #### 数据范围
					  
					  $1 \le A 的长度 \le 100000$,  
					  $0 \le B \le 10000$
					- #### 输入样例：
					  
					  ```
					  2
					  3
					  ```
					- #### 输出样例：
					  
					  ```
					  6
					  ```
					- *题解*
						- ```cpp
						  #include<iostream>
						  #include<vector>
						  
						  using namespace std;
						  
						  vector<int> mul(vector<int> &A, int b) {
						      vector<int> C;
						      int t = 0;
						      for (int i = 0; i < A.size() || t; i++) {
						          if (i < A.size()) t += A[i] * b;
						          C.push_back(t % 10);
						          t /= 10;
						      }
						      while (C.size() > 1 && C.back() == 0) C.pop_back();  //去除前导0
						      return C;
						  }
						  
						  int main() {
						      string a;
						      int b;
						      cin >> a >> b;
						      vector<int> A;
						      for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
						      auto C = mul(A, b);
						      for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
						      return 0;
						  }
						  ```
			- ## 高精度除法
			  collapsed:: true
				- 高精度除法是指在进行除法运算时保留较高的精度，通常用于处理需要更精确结果的场景，比如金融计算或科学研究。在计算机编程中，可以使用大数运算或者特定的库来实现高精度除法，以避免由于标准的浮点数运算产生的精度损失。一些常用的编程语言提供了用于高精度运算的库或方法，例如Java中的BigDecimal类、Python中的decimal模块，以及C++中的GMP和MPFR库等。
				- ### ***高精度除以低精度——模板***
				  collapsed:: true
					- ```cpp
					  // A / b = C ... r, A >= 0, b > 0
					  vector<int> div(vector<int> &A, int b, int &r)
					  {
					      vector<int> C;
					      r = 0;
					      for (int i = A.size() - 1; i >= 0; i -- )
					      {
					          r = r * 10 + A[i];
					          C.push_back(r / b);
					          r %= b;
					      }
					      reverse(C.begin(), C.end());
					      while (C.size() > 1 && C.back() == 0) C.pop_back();
					      return C;
					  }
					  ```
				- ### 例题
				  collapsed:: true
					- 给定两个非负整数（不含前导 $0$） $A，B$，请你计算 $A / B$ 的商和余数。
					- #### 输入格式
					  
					  共两行，第一行包含整数 $A$，第二行包含整数 $B$。
					- #### 输出格式
					  
					  共两行，第一行输出所求的商，第二行输出所求余数。
					- #### 数据范围
					  
					  $1 \le A的长度 \le 100000$,  
					  $1 \le B \le 10000$,  
					  $B$ 一定不为 $0$
					- #### 输入样例：
					  
					  ```
					  7
					  2
					  ```
					- #### 输出样例：
					  
					  ```
					  3
					  1
					  ```
					- *题解*
						- ```C++
						  #include <iostream>
						  #include <vector>
						  #include <algorithm>
						  
						  using namespace std;
						  
						  vector<int> div(vector<int>& A, int b, int& r) {
						      vector<int> C;
						      r = 0;
						      for (int i = A.size() - 1; i >= 0; i--) {
						          r = r * 10 + A[i];
						          C.push_back(r / b);
						          r %= b;
						      }
						      reverse(C.begin(), C.end());
						      while (C.size() > 1 && C.back() == 0) C.pop_back(); // 去除前导0
						      return C;
						  }
						  
						  int main() {
						      string a;
						      int b;
						      cin >> a >> b;
						      vector<int> A;
						      for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
						      int r;
						      vector<int> C = div(A, b, r);
						      for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
						      cout << endl << r << endl;
						  
						      return 0;
						  }
						  ```
		- ## **前缀和与差分**
		  collapsed:: true
			- ## 一维前缀和
			  collapsed:: true
				-
			- ## 二维前缀和
			- ## 一维差分
			- ## 二维差分
		- ## **双指针**
		  collapsed:: true
			- C++中的双指针技术指的是使用两个指针来解决特定类型的问题。双指针通常用于数组、链表或字符串等数据结构的问题，其中两个指针通常都从数组或链表的不同位置开始，根据问题的需要移动指针，执行某种操作，直到满足特定条件为止。这种技术常见的应用包括求解数组中的两数之和、反转链表、判断链表是否有环等。通过灵活运用双指针技术，可以解决许多复杂的数据结构和算法问题。
			- ### ***模板***
			  collapsed:: true
				- ```cpp
				  for (int i = 0, j = 0; i < n; i ++ )
				  {
				      while (j < i && check(i, j)) j ++ ;
				  
				      // 具体问题的逻辑
				  }
				  常见问题分类：
				      (1) 对于一个序列，用两个指针维护一段区间
				      (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
				  ```
			- ### 例题
				- 给定一个长度为 $n$ 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
				- #### 输入格式
				  
				  第一行包含整数 $n$。
				  
				  第二行包含 $n$ 个整数（均在 $0 \sim 10^5$ 范围内），表示整数序列。
				- #### 输出格式
				  
				  共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
				- #### 数据范围
				  
				  $1 \le n \le 10^5$
				- #### 输入样例：
				  
				  ```
				  5
				  1 2 2 3 5
				  ```
				- #### 输出样例：
				  
				  ```
				  3
				  ```
				- ***题解***
					- ```cpp
					  #include<iostream>
					  
					  using namespace std;
					  
					  const int N = 100010;
					  
					  int n ;
					  
					  int a[N] ,s[N];
					  
					  int main()
					  {
					      cin>>n;
					      for(int i = 0 ;i<n;i++) cin>>a[i];
					      
					      int res = 0;
					      
					      for(int i = 0,j = 0 ;i<n;i++)
					      {
					          s[a[i]] ++;
					          while(s[a[i]] > 1)
					          {
					              s[a[j]] --;
					              j++;
					          }
					          
					          res = max(res,i - j + 1);
					          
					      }
					      cout<<res<<endl;
					      
					      return  0 ;
					  }
					  ```
	- # 数据结构